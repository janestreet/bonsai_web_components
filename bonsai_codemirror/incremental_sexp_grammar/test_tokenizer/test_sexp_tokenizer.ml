open! Core
open Codemirror_incremental_sexp_grammar.Tokenizer
module Syntax_error = Codemirror_incremental_sexp_grammar.Syntax_error

let get_all_tokens string =
  let tokens, errors, t = process_string initial string in
  let end_tokens, end_errors = process_eoi t in
  tokens @ end_tokens, errors @ end_errors
;;

let print_tokens =
  List.iter ~f:(fun (token : Token.t) ->
    print_endline (Token_type.sexp_of_t token.token_type |> Sexp.to_string))
;;

let tokenizer_roundtrip string =
  let tokens, errors = get_all_tokens string in
  match errors with
  | [] -> Token.to_sexp_string tokens
  | _ ->
    String.concat
      ~sep:"\n\n"
      (Token.to_sexp_string tokens
       :: List.map
            errors
            ~f:(Syntax_error.to_string_referencing_input ~input_string:string))
;;

let print_test_string s =
  print_endline s;
  print_endline (tokenizer_roundtrip s);
  print_endline ""
;;

let assert_sexp_roundtrips sexp =
  let sexp_string = Sexp.to_string sexp in
  let token_string = tokenizer_roundtrip sexp_string in
  assert (String.(sexp_string = token_string))
;;

let print_and_assert_roundtrip t sexp_of_t =
  sexp_of_t t |> Sexp.to_string |> print_endline;
  assert_sexp_roundtrips (sexp_of_t t)
;;

type t1 = int * int [@@deriving sexp_of]

type t2 =
  { a : int list
  ; b : t1
  }
[@@deriving sexp_of]

type t3 =
  | A of [ `One | `Two ]
  | B of { c : t3 option }
[@@deriving sexp_of]

let%expect_test "basic valid tests" =
  print_and_assert_roundtrip (2, 35) sexp_of_t1;
  print_and_assert_roundtrip { a = []; b = 5, -6 } sexp_of_t2;
  print_and_assert_roundtrip (B { c = Some (B { c = Some (A `One) }) }) sexp_of_t3;
  print_and_assert_roundtrip "multiple sexps" String.sexp_of_t;
  [%expect
    {|
    (2 35)
    ((a())(b(5 -6)))
    (B(c((B(c((A One)))))))
    "multiple sexps"
    |}]
;;

let%quick_test "autogenerated sexp tokenization roundtrips + doesn't error" =
  fun (sexp : Sexp.t) ->
  assert_sexp_roundtrips sexp;
  [%expect {| |}]
;;

let%expect_test "comments" =
  let line_comment = ";;; #|\"#|\n(test ; ignored\ntest2) ;;;; ()" in
  let sexp_comment =
    "(\"not ignoring\" #; (ignoring) (#; \"still ignoring\") \"not ignoring again\")"
  in
  let block_comment = "(a #|b c \"d\"#|e|# f|# g)" in
  print_test_string line_comment;
  print_test_string sexp_comment;
  print_test_string block_comment;
  print_test_string "#| \" |# \" |#";
  [%expect
    {|
    ;;; #|"#|
    (test ; ignored
    test2) ;;;; ()
    (test test2)

    ("not ignoring" #; (ignoring) (#; "still ignoring") "not ignoring again")
    ("not ignoring"()"not ignoring again")

    (a #|b c "d"#|e|# f|# g)
    (a g)

    #| " |# " |#
    |}]
;;

let%expect_test "escaping strings" =
  print_test_string "\"\\065\\066\\067\\000\\\\\\n\\\"\\x00\\xff\\xAc\\255\"";
  [%expect
    {|
    "\065\066\067\000\\\n\"\x00\xff\xAc\255"
    "ABC\000\\\n\"\000\255\172\255"
    |}]
;;

let%expect_test "can recover from error cases" =
  print_test_string "(\"bad \\700\" ok)";
  print_test_string "(\"bad \\70g\" ok)";
  print_test_string "(bad#| also_bad|# ok)";
  print_test_string "\"test ";
  print_test_string "(|# ok)";
  [%expect
    {|
    ("bad \700" ok)
    ("bad "ok)

    [Parse Error] Escape code not in ASCII range: 700
    1| ("bad \700" ok)
        ^^^^^^^^^

    ("bad \70g" ok)
    ("bad "ok)

    [Parse Error] Unexpected character in escape sequence: g
    1| ("bad \70g" ok)
        ^^^^^^^^^

    (bad#| also_bad|# ok)
    ("bad#|""also_bad|#"ok)

    [Parse Error] Comment tokens not allowed in unquoted atoms
    1| (bad#| also_bad|# ok)
        ^^^^^

    [Parse Error] Comment tokens not allowed in unquoted atoms
    1| (bad#| also_bad|# ok)
              ^^^^^^^^^^

    "test


    [Parse Error] Unterminated string
    1| "test
       ^^^^^^

    (|# ok)
    ("|#"ok)

    [Parse Error] Comment tokens not allowed in unquoted atoms
    1| (|# ok)
        ^^
    |}]
;;

let process_string_print_errors t s =
  let toks, errs, t' = process_string t s in
  List.iter errs ~f:(fun x -> print_endline (Syntax_error.to_string x));
  toks, t'
;;

let%expect_test "eoi properly ends tokens" =
  let t1_tokens, t1 = process_string_print_errors initial "testing" in
  let t2_tokens, _ = process_eoi t1 in
  print_endline "before";
  print_tokens t1_tokens;
  print_endline "after";
  print_tokens t2_tokens;
  [%expect
    {|
    before
    after
    (String testing)
    |}]
;;

let%expect_test "tokenization is resumable" =
  let start_tokens, t1 = process_string_print_errors initial "(testing_" in
  let abc_tokens, _ = process_string_print_errors t1 "abc)" in
  let def_tokens, _ = process_string_print_errors t1 "def)" in
  print_tokens start_tokens;
  print_endline "";
  print_tokens abc_tokens;
  print_endline "";
  print_tokens def_tokens;
  [%expect
    {|
    Lparen

    (String testing_abc)
    Rparen

    (String testing_def)
    Rparen
    |}]
;;

let remove_wrapping_quotes_if_present s =
  if String.is_prefix s ~prefix:"\"" && String.is_suffix s ~suffix:"\""
  then String.slice s 1 (String.length s - 1) |> Scanf.unescaped
  else s
;;

let test_positions_correct str =
  let tokens, errs = get_all_tokens str in
  (match errs with
   | [] -> ()
   | errs -> Error.raise_s [%message "ERROR" (errs : Syntax_error.t list)]);
  List.iter tokens ~f:(fun { token_type; pos = { offset_start; offset_end }; _ } ->
    let from_token =
      match token_type with
      | Lparen -> "("
      | Rparen -> ")"
      | String str -> str
    in
    let from_string =
      String.slice str offset_start offset_end |> remove_wrapping_quotes_if_present
    in
    if not (String.equal from_token from_string)
    then
      Error.raise_s
        [%message
          "ERROR: WRONG TOKEN POSITION"
            (str : string)
            (offset_start : int)
            (offset_end : int)
            (from_token : string)
            (from_string : string)])
;;

let%quick_test "tokenizer returns correct positions" =
  fun (sexp : Sexp.t) ->
  let str_mach = Sexp.to_string_mach sexp in
  test_positions_correct str_mach;
  [%expect {| |}];
  let str_hum = Sexp.to_string_hum sexp in
  test_positions_correct str_hum;
  [%expect {| |}]
;;
