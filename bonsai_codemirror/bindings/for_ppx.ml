[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Js_of_ocaml
open! Gen_js_api
open Custom_ojs_converter

module Promise = struct
  type ('a, 'e) t = Ojs.t

  let rec t_of_js : 'a 'e. (Ojs.t -> 'a) -> (Ojs.t -> 'e) -> Ojs.t -> ('a, 'e) t =
    fun (type __a __e) (__a_of_js : Ojs.t -> __a) (__e_of_js : Ojs.t -> __e) (x2 : Ojs.t) ->
    x2

  and t_to_js : 'a 'e. ('a -> Ojs.t) -> ('e -> Ojs.t) -> ('a, 'e) t -> Ojs.t =
    fun (type __a __e) (__a_to_js : __a -> Ojs.t) (__e_to_js : __e -> Ojs.t) (x1 : Ojs.t) ->
    x1
  ;;

  let create : (('a -> unit) -> ('e -> unit) -> unit) -> ('a, 'e) t =
    fun (x3 : ('a -> unit) -> ('e -> unit) -> unit) ->
    t_of_js
      Obj.magic
      Obj.magic
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "Promise")
         [| Ojs.fun_to_js 2 (fun (x4 : Ojs.t) (x6 : Ojs.t) ->
              x3
                (fun (x5 : 'a) -> ignore (Ojs.apply x4 [| Obj.magic x5 |]))
                (fun (x7 : 'e) -> ignore (Ojs.apply x6 [| Obj.magic x7 |])))
         |])
  ;;
end

module RegExp = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x11 : Ojs.t) -> x11
  and t_to_js : t -> Ojs.t = fun (x10 : Ojs.t) -> x10

  let create : string -> string option -> t =
    fun (x12 : string) (x13 : string option) ->
    t_of_js
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "RegExp")
         [| Ojs.string_to_js x12; Ojs.option_to_js Ojs.string_to_js x13 |])
  ;;
end

module Text = struct
  module Line = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x16 : Ojs.t) -> x16
    and t_to_js : t -> Ojs.t = fun (x15 : Ojs.t) -> x15

    let from : t -> int =
      fun (x17 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x17) "from")
    ;;

    let to_ : t -> int =
      fun (x18 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x18) "to")
    ;;

    let number : t -> int =
      fun (x19 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x19) "number")
    ;;

    let text : t -> string =
      fun (x20 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x20) "text")
    ;;

    let length : t -> int =
      fun (x21 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x21) "length")
    ;;
  end

  module Text_iterator = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x23 : Ojs.t) -> x23
    and t_to_js : t -> Ojs.t = fun (x22 : Ojs.t) -> x22

    let next : t -> ?skip:int -> unit -> t =
      fun (x27 : t) ?skip:(x24 : int option) () ->
      t_of_js
        (let x28 = t_to_js x27 in
         Ojs.call
           (Ojs.get_prop_ascii x28 "next")
           "apply"
           [| x28
            ; (let x25 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x24 with
                | Some x26 -> ignore (Ojs.call x25 "push" [| Ojs.int_to_js x26 |])
                | None -> ());
               x25)
           |])
    ;;

    let value : t -> string =
      fun (x29 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x29) "value")
    ;;

    let done_ : t -> bool =
      fun (x30 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x30) "done")
    ;;

    let line_break : t -> bool =
      fun (x31 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x31) "lineBreak")
    ;;
  end

  module Text = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x33 : Ojs.t) -> x33
    and t_to_js : t -> Ojs.t = fun (x32 : Ojs.t) -> x32

    let length : t -> int =
      fun (x34 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x34) "length")
    ;;

    let lines : t -> int =
      fun (x35 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x35) "lines")
    ;;

    let line_at : t -> int -> Line.t =
      fun (x37 : t) (x36 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x37) "lineAt" [| Ojs.int_to_js x36 |])
    ;;

    let line : t -> int -> Line.t =
      fun (x39 : t) (x38 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x39) "line" [| Ojs.int_to_js x38 |])
    ;;

    let replace : t -> from:int -> to_:int -> with_:t -> t =
      fun (x43 : t) ~from:(x40 : int) ~to_:(x41 : int) ~with_:(x42 : t) ->
      t_of_js
        (Ojs.call
           (t_to_js x43)
           "replace"
           [| Ojs.int_to_js x40; Ojs.int_to_js x41; t_to_js x42 |])
    ;;

    let append : t -> t -> t =
      fun (x45 : t) (x44 : t) ->
      t_of_js (Ojs.call (t_to_js x45) "append" [| t_to_js x44 |])
    ;;

    let slice : t -> from:int -> ?to_:int -> unit -> t =
      fun (x50 : t) ~from:(x46 : int) ?to_:(x47 : int option) () ->
      t_of_js
        (let x51 = t_to_js x50 in
         Ojs.call
           (Ojs.get_prop_ascii x51 "slice")
           "apply"
           [| x51
            ; (let x48 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x48 "push" [| Ojs.int_to_js x46 |]);
               (match x47 with
                | Some x49 -> ignore (Ojs.call x48 "push" [| Ojs.int_to_js x49 |])
                | None -> ());
               x48)
           |])
    ;;

    let slice_string : t -> from:int -> ?to_:int -> ?line_sep:string -> unit -> string =
      fun (x58 : t)
        ~from:(x52 : int)
        ?to_:(x53 : int option)
        ?line_sep:(x54 : string option)
        () ->
      Ojs.string_of_js
        (let x59 = t_to_js x58 in
         Ojs.call
           (Ojs.get_prop_ascii x59 "sliceString")
           "apply"
           [| x59
            ; (let x55 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x55 "push" [| Ojs.int_to_js x52 |]);
               (match x53 with
                | Some x57 -> ignore (Ojs.call x55 "push" [| Ojs.int_to_js x57 |])
                | None -> ());
               (match x54 with
                | Some x56 -> ignore (Ojs.call x55 "push" [| Ojs.string_to_js x56 |])
                | None -> ());
               x55)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x61 : t) (x60 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x61) "eq" [| t_to_js x60 |])
    ;;

    let iter : t -> ?dir:int -> unit -> Text_iterator.t =
      fun (x65 : t) ?dir:(x62 : int option) () ->
      Text_iterator.t_of_js
        (let x66 = t_to_js x65 in
         Ojs.call
           (Ojs.get_prop_ascii x66 "iter")
           "apply"
           [| x66
            ; (let x63 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x62 with
                | Some x64 -> ignore (Ojs.call x63 "push" [| Ojs.int_to_js x64 |])
                | None -> ());
               x63)
           |])
    ;;

    let iter_range : t -> from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x71 : t) ~from:(x67 : int) ?to_:(x68 : int option) () ->
      Text_iterator.t_of_js
        (let x72 = t_to_js x71 in
         Ojs.call
           (Ojs.get_prop_ascii x72 "iterRange")
           "apply"
           [| x72
            ; (let x69 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x69 "push" [| Ojs.int_to_js x67 |]);
               (match x68 with
                | Some x70 -> ignore (Ojs.call x69 "push" [| Ojs.int_to_js x70 |])
                | None -> ());
               x69)
           |])
    ;;

    let iter_lines : t -> ?from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x78 : t) ?from:(x73 : int option) ?to_:(x74 : int option) () ->
      Text_iterator.t_of_js
        (let x79 = t_to_js x78 in
         Ojs.call
           (Ojs.get_prop_ascii x79 "iterLines")
           "apply"
           [| x79
            ; (let x75 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x73 with
                | Some x77 -> ignore (Ojs.call x75 "push" [| Ojs.int_to_js x77 |])
                | None -> ());
               (match x74 with
                | Some x76 -> ignore (Ojs.call x75 "push" [| Ojs.int_to_js x76 |])
                | None -> ());
               x75)
           |])
    ;;

    let to_json : t -> string list =
      fun (x80 : t) ->
      Ojs.list_of_js Ojs.string_of_js (Ojs.call (t_to_js x80) "toJSON" [||])
    ;;

    let of_ : string list -> t =
      fun (x82 : string list) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.list_to_js Ojs.string_to_js x82 |])
    ;;

    let of_array : string array -> t =
      fun (x84 : string array) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.array_to_js Ojs.string_to_js x84 |])
    ;;

    let empty : t =
      t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "empty")
    ;;
  end

  let count_column : string -> n:int -> tab_size:int -> int =
    fun (x88 : string) ~n:(x86 : int) ~tab_size:(x87 : int) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.string_to_js x88)
         "countColumn"
         [| Ojs.int_to_js x86; Ojs.int_to_js x87 |])
  ;;

  module Offset_and_left_over = struct
    type t =
      { offset : int
      ; left_over : int
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x90 : Ojs.t) ->
      { offset = Ojs.int_of_js (Ojs.get_prop_ascii x90 "offset")
      ; left_over = Ojs.int_of_js (Ojs.get_prop_ascii x90 "leftOver")
      }

    and t_to_js : t -> Ojs.t =
      fun (x89 : t) ->
      Ojs.obj
        [| "offset", Ojs.int_to_js x89.offset; "leftOver", Ojs.int_to_js x89.left_over |]
    ;;
  end

  let find_column : string -> n:int -> col:int -> tab_size:int -> Offset_and_left_over.t =
    fun (x94 : string) ~n:(x91 : int) ~col:(x92 : int) ~tab_size:(x93 : int) ->
    Offset_and_left_over.t_of_js
      (Ojs.call
         (Ojs.string_to_js x94)
         "findColumn"
         [| Ojs.int_to_js x91; Ojs.int_to_js x92; Ojs.int_to_js x93 |])
  ;;

  let code_point_at : string -> int -> int =
    fun (x96 : string) (x95 : int) ->
    Ojs.int_of_js (Ojs.call (Ojs.string_to_js x96) "codePointAt" [| Ojs.int_to_js x95 |])
  ;;

  let from_code_point : int -> string =
    fun (x97 : int) ->
    Ojs.string_of_js (Ojs.call (Ojs.int_to_js x97) "fromCodePoint" [||])
  ;;

  let code_point_size : int -> int =
    fun (x98 : int) -> Ojs.int_of_js (Ojs.call (Ojs.int_to_js x98) "codePointSize" [||])
  ;;

  let find_cluster_break : string -> int -> ?forward:bool -> unit -> int =
    fun (x103 : string) (x99 : int) ?forward:(x100 : bool option) () ->
    Ojs.int_of_js
      (let x104 = Ojs.string_to_js x103 in
       Ojs.call
         (Ojs.get_prop_ascii x104 "findClusterBreak")
         "apply"
         [| x104
          ; (let x101 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore (Ojs.call x101 "push" [| Ojs.int_to_js x99 |]);
             (match x100 with
              | Some x102 -> ignore (Ojs.call x101 "push" [| Ojs.bool_to_js x102 |])
              | None -> ());
             x101)
         |])
  ;;
end

module State = struct
  module Extension = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x106 : Ojs.t) -> x106
    and t_to_js : t -> Ojs.t = fun (x105 : Ojs.t) -> x105

    let of_list : t list -> t =
      fun (x107 : t list) -> t_of_js (Ojs.list_to_js t_to_js x107)
    ;;
  end

  module Editor_state_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x110 : Ojs.t) -> x110
    and t_to_js : t -> Ojs.t = fun (x109 : Ojs.t) -> x109

    let create : ?doc:string -> ?extensions:Extension.t list -> unit -> t =
      fun ?doc:(x111 : string option) ?extensions:(x112 : Extension.t list option) () ->
      let x113 = Ojs.empty_obj () in
      (match x111 with
       | Some x116 -> Ojs.set_prop_ascii x113 "doc" (Ojs.string_to_js x116)
       | None -> ());
      (match x112 with
       | Some x114 ->
         Ojs.set_prop_ascii x113 "extensions" (Ojs.list_to_js Extension.t_to_js x114)
       | None -> ());
      t_of_js x113
    ;;
  end

  type state_effect = Ojs.t

  let rec state_effect_of_js : Ojs.t -> state_effect = fun (x118 : Ojs.t) -> x118
  and state_effect_to_js : state_effect -> Ojs.t = fun (x117 : Ojs.t) -> x117

  module State_effect_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x120 : Ojs.t) -> x120

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x119 : Ojs.t) -> x119
    ;;

    let of_ : 'a t -> 'a -> state_effect =
      fun (x122 : 'a t) (x121 : 'a) ->
      state_effect_of_js (Ojs.call (t_to_js Obj.magic x122) "of" [| Obj.magic x121 |])
    ;;
  end

  module State_effect = struct
    type t = state_effect

    let rec t_of_js : Ojs.t -> t = fun (x125 : Ojs.t) -> state_effect_of_js x125
    and t_to_js : t -> Ojs.t = fun (x124 : state_effect) -> state_effect_to_js x124

    let value : t -> 'a =
      fun (x126 : t) -> Obj.magic (Ojs.get_prop_ascii (t_to_js x126) "value")
    ;;

    let is : t -> type_:'a State_effect_type.t -> bool =
      fun (x129 : t) ~type_:(x127 : 'a State_effect_type.t) ->
      Ojs.bool_of_js
        (Ojs.call (t_to_js x129) "is" [| State_effect_type.t_to_js Obj.magic x127 |])
    ;;

    let define : unit -> 'a State_effect_type.t =
      fun () ->
      State_effect_type.t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "define"
           [||])
    ;;

    let reconfigure : Extension.t State_effect_type.t =
      State_effect_type.t_of_js
        Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "reconfigure")
    ;;
  end

  module Annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x133 : Ojs.t) -> x133
    and t_to_js : t -> Ojs.t = fun (x132 : Ojs.t) -> x132
  end

  module Effects_and_annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x135 : Ojs.t) -> x135
    and t_to_js : t -> Ojs.t = fun (x134 : Ojs.t) -> x134

    let create
      : ?effects:State_effect.t list -> ?annotations:Annotation.t list -> unit -> t
      =
      fun ?effects:(x136 : State_effect.t list option)
        ?annotations:(x137 : Annotation.t list option)
        () ->
      let x138 = Ojs.empty_obj () in
      (match x136 with
       | Some x141 ->
         Ojs.set_prop_ascii x138 "effects" (Ojs.list_to_js State_effect.t_to_js x141)
       | None -> ());
      (match x137 with
       | Some x139 ->
         Ojs.set_prop_ascii x138 "annotations" (Ojs.list_to_js Annotation.t_to_js x139)
       | None -> ());
      t_of_js x138
    ;;
  end

  type change_set = Ojs.t

  let rec change_set_of_js : Ojs.t -> change_set = fun (x144 : Ojs.t) -> x144
  and change_set_to_js : change_set -> Ojs.t = fun (x143 : Ojs.t) -> x143

  module Change_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x146 : Ojs.t) -> x146
    and t_to_js : t -> Ojs.t = fun (x145 : Ojs.t) -> x145

    let single : ?from:int -> ?to_:int -> ?insert:Text.Text.t -> unit -> t =
      fun ?from:(x147 : int option)
        ?to_:(x148 : int option)
        ?insert:(x149 : Text.Text.t option)
        () ->
      let x150 = Ojs.empty_obj () in
      (match x147 with
       | Some x153 -> Ojs.set_prop_ascii x150 "from" (Ojs.int_to_js x153)
       | None -> ());
      (match x148 with
       | Some x152 -> Ojs.set_prop_ascii x150 "to" (Ojs.int_to_js x152)
       | None -> ());
      (match x149 with
       | Some x151 -> Ojs.set_prop_ascii x150 "insert" (Text.Text.t_to_js x151)
       | None -> ());
      t_of_js x150
    ;;

    let change_set : change_set -> t =
      fun (x154 : change_set) -> t_of_js (change_set_to_js x154)
    ;;

    let many : t list -> t = fun (x155 : t list) -> t_of_js (Ojs.list_to_js t_to_js x155)
  end

  module Map_mode = struct
    type t =
      | Simple
      | TrackDel
      | TrackBefore
      | TrackAfter

    let rec t_of_js : Ojs.t -> t =
      fun (x158 : Ojs.t) ->
      let x159 = x158 in
      match Ojs.string_of_js x159 with
      | "Simple" -> Simple
      | "TrackDel" -> TrackDel
      | "TrackBefore" -> TrackBefore
      | "TrackAfter" -> TrackAfter
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x157 : t) ->
      match x157 with
      | Simple -> Ojs.string_to_js "Simple"
      | TrackDel -> Ojs.string_to_js "TrackDel"
      | TrackBefore -> Ojs.string_to_js "TrackBefore"
      | TrackAfter -> Ojs.string_to_js "TrackAfter"
    ;;
  end

  module Cursor_association = struct
    type t =
      | Left
      | None
      | Right

    let rec t_of_js : Ojs.t -> t =
      fun (x161 : Ojs.t) ->
      let x162 = x161 in
      match Ojs.int_of_js x162 with
      | -1 -> Left
      | 0 -> None
      | 1 -> Right
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x160 : t) ->
      match x160 with
      | Left -> Ojs.int_to_js (-1)
      | None -> Ojs.int_to_js 0
      | Right -> Ojs.int_to_js 1
    ;;
  end

  module Touches_range = struct
    type t =
      | True
      | False
      | Cover

    let rec t_of_js : Ojs.t -> t =
      fun (x164 : Ojs.t) ->
      let x165 = x164 in
      match Ojs.type_of x165 with
      | "string" ->
        (match Ojs.string_of_js x165 with
         | "cover" -> Cover
         | _ -> assert false)
      | "boolean" ->
        (match Ojs.bool_of_js x165 with
         | true -> True
         | false -> False)
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x163 : t) ->
      match x163 with
      | True -> Ojs.bool_to_js true
      | False -> Ojs.bool_to_js false
      | Cover -> Ojs.string_to_js "cover"
    ;;
  end

  module Change_desc = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x167 : Ojs.t) -> x167
    and t_to_js : t -> Ojs.t = fun (x166 : Ojs.t) -> x166

    let length : t -> int =
      fun (x168 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x168) "length")
    ;;

    let new_length : t -> int =
      fun (x169 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x169) "newLength")
    ;;

    let empty : t -> bool =
      fun (x170 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x170) "empty")
    ;;

    let iter_gaps : t -> f:(a:int -> b:int -> length:int -> unit) -> unit =
      fun (x175 : t) ~f:(x171 : a:int -> b:int -> length:int -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x175)
           "iterGaps"
           [| Ojs.fun_to_js 3 (fun (x172 : Ojs.t) (x173 : Ojs.t) (x174 : Ojs.t) ->
                x171
                  ~a:(Ojs.int_of_js x172)
                  ~b:(Ojs.int_of_js x173)
                  ~length:(Ojs.int_of_js x174))
           |])
    ;;

    let iter_changed_ranges
      : t -> f:(from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) -> unit
      =
      fun (x181 : t) ~f:(x176 : from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x181)
           "iterChangedRanges"
           [| Ojs.fun_to_js
                4
                (fun (x177 : Ojs.t) (x178 : Ojs.t) (x179 : Ojs.t) (x180 : Ojs.t) ->
                   x176
                     ~from_a:(Ojs.int_of_js x177)
                     ~to_a:(Ojs.int_of_js x178)
                     ~from_b:(Ojs.int_of_js x179)
                     ~to_b:(Ojs.int_of_js x180))
           |])
    ;;

    let inverted_desc : t -> t =
      fun (x182 : t) -> t_of_js (Ojs.get_prop_ascii (t_to_js x182) "invertedDesc")
    ;;

    let compose_desc : t -> t -> t =
      fun (x184 : t) (x183 : t) ->
      t_of_js (Ojs.call (t_to_js x184) "composeDesc" [| t_to_js x183 |])
    ;;

    let map_desc : t -> t -> ?before:bool -> unit -> t =
      fun (x189 : t) (x185 : t) ?before:(x186 : bool option) () ->
      t_of_js
        (let x190 = t_to_js x189 in
         Ojs.call
           (Ojs.get_prop_ascii x190 "mapDesc")
           "apply"
           [| x190
            ; (let x187 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x187 "push" [| t_to_js x185 |]);
               (match x186 with
                | Some x188 -> ignore (Ojs.call x187 "push" [| Ojs.bool_to_js x188 |])
                | None -> ());
               x187)
           |])
    ;;

    let map_pos : t -> int -> assoc:Cursor_association.t -> mode:Map_mode.t -> t =
      fun (x194 : t)
        (x191 : int)
        ~assoc:(x192 : Cursor_association.t)
        ~mode:(x193 : Map_mode.t) ->
      t_of_js
        (Ojs.call
           (t_to_js x194)
           "mapPos"
           [| Ojs.int_to_js x191
            ; Cursor_association.t_to_js x192
            ; Map_mode.t_to_js x193
           |])
    ;;

    let touches_range : t -> from:int -> ?to_:int -> unit -> Touches_range.t =
      fun (x199 : t) ~from:(x195 : int) ?to_:(x196 : int option) () ->
      Touches_range.t_of_js
        (let x200 = t_to_js x199 in
         Ojs.call
           (Ojs.get_prop_ascii x200 "touchesRange")
           "apply"
           [| x200
            ; (let x197 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x197 "push" [| Ojs.int_to_js x195 |]);
               (match x196 with
                | Some x198 -> ignore (Ojs.call x197 "push" [| Ojs.int_to_js x198 |])
                | None -> ());
               x197)
           |])
    ;;
  end

  module Selection_range = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x202 : Ojs.t) -> x202
    and t_to_js : t -> Ojs.t = fun (x201 : Ojs.t) -> x201

    let from : t -> int =
      fun (x203 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x203) "from")
    ;;

    let to_ : t -> int =
      fun (x204 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x204) "to")
    ;;

    let anchor : t -> int =
      fun (x205 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x205) "anchor")
    ;;

    let head : t -> int =
      fun (x206 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x206) "head")
    ;;

    let empty : t -> bool =
      fun (x207 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x207) "empty")
    ;;

    let assoc : t -> Cursor_association.t =
      fun (x208 : t) ->
      Cursor_association.t_of_js (Ojs.get_prop_ascii (t_to_js x208) "assoc")
    ;;

    let bidi_level : t -> int option =
      fun (x209 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x209) "bidiLevel")
    ;;

    let goal_column : t -> int option =
      fun (x211 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x211) "goalColumn")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x217 : t) (x213 : Change_desc.t) ?assoc:(x214 : Cursor_association.t option) () ->
      t_of_js
        (let x218 = t_to_js x217 in
         Ojs.call
           (Ojs.get_prop_ascii x218 "map")
           "apply"
           [| x218
            ; (let x215 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x215 "push" [| Change_desc.t_to_js x213 |]);
               (match x214 with
                | Some x216 ->
                  ignore (Ojs.call x215 "push" [| Cursor_association.t_to_js x216 |])
                | None -> ());
               x215)
           |])
    ;;

    let extend : t -> from:int -> ?to_:int -> unit -> t =
      fun (x223 : t) ~from:(x219 : int) ?to_:(x220 : int option) () ->
      t_of_js
        (let x224 = t_to_js x223 in
         Ojs.call
           (Ojs.get_prop_ascii x224 "extend")
           "apply"
           [| x224
            ; (let x221 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x221 "push" [| Ojs.int_to_js x219 |]);
               (match x220 with
                | Some x222 -> ignore (Ojs.call x221 "push" [| Ojs.int_to_js x222 |])
                | None -> ());
               x221)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x226 : t) (x225 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x226) "eq" [| t_to_js x225 |])
    ;;

    let to_json : t -> Ojs.t = fun (x227 : t) -> Ojs.call (t_to_js x227) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x228 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "SelectionRange")
           "fromJSON"
           [| x228 |])
    ;;
  end

  module Editor_selection = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x230 : Ojs.t) -> x230
    and t_to_js : t -> Ojs.t = fun (x229 : Ojs.t) -> x229

    let ranges : t -> Selection_range.t list =
      fun (x231 : t) ->
      Ojs.list_of_js Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x231) "ranges")
    ;;

    let main_index : t -> int =
      fun (x233 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x233) "mainIndex")
    ;;

    let main : t -> Selection_range.t =
      fun (x234 : t) -> Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x234) "main")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x239 : t) (x235 : Change_desc.t) ?assoc:(x236 : Cursor_association.t option) () ->
      t_of_js
        (let x240 = t_to_js x239 in
         Ojs.call
           (Ojs.get_prop_ascii x240 "map")
           "apply"
           [| x240
            ; (let x237 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x237 "push" [| Change_desc.t_to_js x235 |]);
               (match x236 with
                | Some x238 ->
                  ignore (Ojs.call x237 "push" [| Cursor_association.t_to_js x238 |])
                | None -> ());
               x237)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x242 : t) (x241 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x242) "eq" [| t_to_js x241 |])
    ;;

    let as_single : t -> t =
      fun (x243 : t) -> t_of_js (Ojs.call (t_to_js x243) "asSingle" [||])
    ;;

    let add_range : t -> Selection_range.t -> ?main:bool -> unit -> t =
      fun (x248 : t) (x244 : Selection_range.t) ?main:(x245 : bool option) () ->
      t_of_js
        (let x249 = t_to_js x248 in
         Ojs.call
           (Ojs.get_prop_ascii x249 "addRange")
           "apply"
           [| x249
            ; (let x246 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x246 "push" [| Selection_range.t_to_js x244 |]);
               (match x245 with
                | Some x247 -> ignore (Ojs.call x246 "push" [| Ojs.bool_to_js x247 |])
                | None -> ());
               x246)
           |])
    ;;

    let replace_range : Selection_range.t -> ?which:int -> unit -> t =
      fun (x253 : Selection_range.t) ?which:(x250 : int option) () ->
      t_of_js
        (let x254 = Selection_range.t_to_js x253 in
         Ojs.call
           (Ojs.get_prop_ascii x254 "replaceRange")
           "apply"
           [| x254
            ; (let x251 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x250 with
                | Some x252 -> ignore (Ojs.call x251 "push" [| Ojs.int_to_js x252 |])
                | None -> ());
               x251)
           |])
    ;;

    let to_json : t -> Ojs.t = fun (x255 : t) -> Ojs.call (t_to_js x255) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x256 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorSelection")
           "fromJSON"
           [| x256 |])
    ;;

    let single : anchor:int -> ?head:int -> unit -> t =
      fun ~anchor:(x257 : int) ?head:(x258 : int option) () ->
      t_of_js
        (let x261 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x261 "single")
           "apply"
           [| x261
            ; (let x259 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x259 "push" [| Ojs.int_to_js x257 |]);
               (match x258 with
                | Some x260 -> ignore (Ojs.call x259 "push" [| Ojs.int_to_js x260 |])
                | None -> ());
               x259)
           |])
    ;;

    let create : ranges:Selection_range.t list -> ?main_index:int -> unit -> t =
      fun ~ranges:(x262 : Selection_range.t list) ?main_index:(x263 : int option) () ->
      t_of_js
        (let x267 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x267 "create")
           "apply"
           [| x267
            ; (let x264 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore
                 (Ojs.call x264 "push" [| Ojs.list_to_js Selection_range.t_to_js x262 |]);
               (match x263 with
                | Some x265 -> ignore (Ojs.call x264 "push" [| Ojs.int_to_js x265 |])
                | None -> ());
               x264)
           |])
    ;;

    let cursor
      :  pos:int -> ?assoc:Cursor_association.t -> ?bidi_level:int -> ?goal_column:int
      -> unit -> Selection_range.t
      =
      fun ~pos:(x268 : int)
        ?assoc:(x269 : Cursor_association.t option)
        ?bidi_level:(x270 : int option)
        ?goal_column:(x271 : int option)
        () ->
      Selection_range.t_of_js
        (let x276 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x276 "cursor")
           "apply"
           [| x276
            ; (let x272 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x272 "push" [| Ojs.int_to_js x268 |]);
               (match x269 with
                | Some x275 ->
                  ignore (Ojs.call x272 "push" [| Cursor_association.t_to_js x275 |])
                | None -> ());
               (match x270 with
                | Some x274 -> ignore (Ojs.call x272 "push" [| Ojs.int_to_js x274 |])
                | None -> ());
               (match x271 with
                | Some x273 -> ignore (Ojs.call x272 "push" [| Ojs.int_to_js x273 |])
                | None -> ());
               x272)
           |])
    ;;

    let range : anchor:int -> head:int -> ?goal_column:int -> unit -> Selection_range.t =
      fun ~anchor:(x277 : int) ~head:(x278 : int) ?goal_column:(x279 : int option) () ->
      Selection_range.t_of_js
        (let x282 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x282 "range")
           "apply"
           [| x282
            ; (let x280 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x280 "push" [| Ojs.int_to_js x277 |]);
               ignore (Ojs.call x280 "push" [| Ojs.int_to_js x278 |]);
               (match x279 with
                | Some x281 -> ignore (Ojs.call x280 "push" [| Ojs.int_to_js x281 |])
                | None -> ());
               x280)
           |])
    ;;
  end

  module Change_set = struct
    type t = change_set

    let rec t_of_js : Ojs.t -> t = fun (x284 : Ojs.t) -> change_set_of_js x284
    and t_to_js : t -> Ojs.t = fun (x283 : change_set) -> change_set_to_js x283

    let iter_changes
      :  t
      -> f:
           (from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit)
      -> unit
      =
      fun (x291 : t)
        ~f:
          (x285 :
            from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x291)
           "iterChanges"
           [| Ojs.fun_to_js
                5
                (fun
                    (x286 : Ojs.t)
                    (x287 : Ojs.t)
                    (x288 : Ojs.t)
                    (x289 : Ojs.t)
                    (x290 : Ojs.t)
                  ->
                   x285
                     ~from_a:(Ojs.int_of_js x286)
                     ~to_a:(Ojs.int_of_js x287)
                     ~from_b:(Ojs.int_of_js x288)
                     ~to_b:(Ojs.int_of_js x289)
                     ~inserted:(Text.Text.t_of_js x290))
           |])
    ;;

    let desc : t -> Change_desc.t =
      fun (x292 : t) -> Change_desc.t_of_js (Ojs.get_prop_ascii (t_to_js x292) "desc")
    ;;
  end

  type editor_state = Ojs.t

  let rec editor_state_of_js : Ojs.t -> editor_state = fun (x294 : Ojs.t) -> x294
  and editor_state_to_js : editor_state -> Ojs.t = fun (x293 : Ojs.t) -> x293

  module Annotation_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x296 : Ojs.t) -> x296

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x295 : Ojs.t) -> x295
    ;;
  end

  module Transaction = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x298 : Ojs.t) -> x298
    and t_to_js : t -> Ojs.t = fun (x297 : Ojs.t) -> x297

    let start_state : t -> editor_state =
      fun (x299 : t) ->
      editor_state_of_js (Ojs.get_prop_ascii (t_to_js x299) "startState")
    ;;

    let changes : t -> Change_set.t =
      fun (x300 : t) -> Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x300) "changes")
    ;;

    let selection : t -> Editor_selection.t option =
      fun (x301 : t) ->
      Ojs.option_of_js
        Editor_selection.t_of_js
        (Ojs.get_prop_ascii (t_to_js x301) "selection")
    ;;

    let effects : t -> State_effect.t list =
      fun (x303 : t) ->
      Ojs.list_of_js State_effect.t_of_js (Ojs.get_prop_ascii (t_to_js x303) "effects")
    ;;

    let scroll_into_view : t -> bool =
      fun (x305 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x305) "scrollIntoView")
    ;;

    let new_doc : t -> Text.Text.t =
      fun (x306 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x306) "newDoc")
    ;;

    let new_selection : t -> Editor_selection.t =
      fun (x307 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x307) "newSelection")
    ;;

    let state : t -> editor_state =
      fun (x308 : t) -> editor_state_of_js (Ojs.get_prop_ascii (t_to_js x308) "state")
    ;;

    let annotation : t -> 'a Annotation_type.t -> 'a option =
      fun (x311 : t) (x309 : 'a Annotation_type.t) ->
      Ojs.option_of_js
        Obj.magic
        (Ojs.call
           (t_to_js x311)
           "annotation"
           [| Annotation_type.t_to_js Obj.magic x309 |])
    ;;

    let doc_changed : t -> bool =
      fun (x313 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x313) "docChanged")
    ;;

    let reconfigured : t -> bool =
      fun (x314 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x314) "reconfigured")
    ;;

    let time : int Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "time")
    ;;

    let user_event : string Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.string_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "userEvent")
    ;;

    let add_to_history : bool Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "addToHistory")
    ;;
  end

  module State_field_config = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x319 : Ojs.t) -> x319

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x318 : Ojs.t) -> x318
    ;;

    let create
      :  create:(editor_state -> 'v) -> update:('v -> Transaction.t -> 'v)
      -> compare:('v -> 'v -> bool) option -> 'v t
      =
      fun ~create:(x320 : editor_state -> 'v)
        ~update:(x321 : 'v -> Transaction.t -> 'v)
        ~compare:(x322 : ('v -> 'v -> bool) option) ->
      let x323 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x323
        "create"
        (Ojs.fun_to_js 1 (fun (x330 : Ojs.t) ->
           Obj.magic (x320 (editor_state_of_js x330))));
      Ojs.set_prop_ascii
        x323
        "update"
        (Ojs.fun_to_js 2 (fun (x328 : Ojs.t) (x329 : Ojs.t) ->
           Obj.magic (x321 (Obj.magic x328) (Transaction.t_of_js x329))));
      Ojs.set_prop_ascii
        x323
        "compare"
        (Ojs.option_to_js
           (fun (x325 : 'v -> 'v -> bool) ->
             Ojs.fun_to_js 2 (fun (x326 : Ojs.t) (x327 : Ojs.t) ->
               Ojs.bool_to_js (x325 (Obj.magic x326) (Obj.magic x327))))
           x322);
      t_of_js Obj.magic x323
    ;;
  end

  module State_field = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x332 : Ojs.t) -> x332

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x331 : Ojs.t) -> x331
    ;;

    let extension : 'v t -> Extension.t =
      fun (x333 : 'v t) ->
      Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x333) "extension")
    ;;

    let init : 'v t -> create:(editor_state -> 'v) -> Extension.t =
      fun (x337 : 'v t) ~create:(x335 : editor_state -> 'v) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic x337)
           "init"
           [| Ojs.fun_to_js 1 (fun (x336 : Ojs.t) ->
                Obj.magic (x335 (editor_state_of_js x336)))
           |])
    ;;

    let define : config:'v State_field_config.t -> 'v t =
      fun ~config:(x339 : 'v State_field_config.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateField")
           "define"
           [| State_field_config.t_to_js Obj.magic x339 |])
    ;;
  end

  module Facet = struct
    type ('i, 'o) t = Ojs.t

    let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
      fun (type __i __o)
        (__i_of_js : Ojs.t -> __i)
        (__o_of_js : Ojs.t -> __o)
        (x343 : Ojs.t) ->
      x343

    and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
      fun (type __i __o)
        (__i_to_js : __i -> Ojs.t)
        (__o_to_js : __o -> Ojs.t)
        (x342 : Ojs.t) ->
      x342
    ;;

    type 'i multi_out = ('i, 'i list) t

    let rec multi_out_of_js : 'i. (Ojs.t -> 'i) -> Ojs.t -> 'i multi_out =
      fun (type __i) (__i_of_js : Ojs.t -> __i) (x348 : Ojs.t) ->
      t_of_js __i_of_js (fun (x350 : Ojs.t) -> Ojs.list_of_js __i_of_js x350) x348

    and multi_out_to_js : 'i. ('i -> Ojs.t) -> 'i multi_out -> Ojs.t =
      fun (type __i) (__i_to_js : __i -> Ojs.t) (x344 : (__i, __i list) t) ->
      t_to_js __i_to_js (fun (x346 : __i list) -> Ojs.list_to_js __i_to_js x346) x344
    ;;

    let of_ : ('i, 'o) t -> 'i With_conversion.t -> Extension.t =
      fun (x354 : ('i, 'o) t) (x352 : 'i With_conversion.t) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x354)
           "of"
           [| With_conversion.t_to_js Obj.magic x352 |])
    ;;

    module Dep = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x360 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x360

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x357 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x357
      ;;

      type t =
        | Doc : t
        | Selection : t

      let rec t_of_js : Ojs.t -> t =
        fun (x364 : Ojs.t) ->
        let x365 = x364 in
        match Ojs.string_of_js x365 with
        | "doc" -> Doc
        | "selection" -> Selection
        | _ -> assert false

      and t_to_js : t -> Ojs.t =
        fun (x363 : t) ->
        match x363 with
        | Doc -> Ojs.string_to_js "doc"
        | Selection -> Ojs.string_to_js "selection"
      ;;
    end

    let compute : ('i, 'o) t -> deps:Dep.t list -> get:(editor_state -> 'i) -> Extension.t
      =
      fun (x370 : ('i, 'o) t) ~deps:(x366 : Dep.t list) ~get:(x368 : editor_state -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x370)
           "compute"
           [| Ojs.list_to_js Dep.t_to_js x366
            ; Ojs.fun_to_js 1 (fun (x369 : Ojs.t) ->
                Obj.magic (x368 (editor_state_of_js x369)))
           |])
    ;;

    let from : ('i, 'o) t -> field:'t State_field.t -> get:(value:'t -> 'i) -> Extension.t
      =
      fun (x377 : ('i, 'o) t)
        ~field:(x373 : 't State_field.t)
        ~get:(x375 : value:'t -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x377)
           "from"
           [| State_field.t_to_js Obj.magic x373
            ; Ojs.fun_to_js 1 (fun (x376 : Ojs.t) ->
                Obj.magic (x375 ~value:(Obj.magic x376)))
           |])
    ;;

    module Config = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x383 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x383

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x380 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x380
      ;;

      type ('i, 'o) t = Ojs.t

      let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x387 : Ojs.t) ->
        x387

      and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x386 : Ojs.t) ->
        x386
      ;;

      let create
        :  combine:('i list -> 'o) -> ?compare:('o -> 'o -> bool)
        -> ?compareInput:('i -> 'i -> bool) -> ?static:bool
        -> ?enables:(('i, 'o) facet -> Extension.t) -> unit -> ('i, 'o) t
        =
        fun ~combine:(x388 : 'i list -> 'o)
          ?compare:(x389 : ('o -> 'o -> bool) option)
          ?compareInput:(x390 : ('i -> 'i -> bool) option)
          ?static:(x391 : bool option)
          ?enables:(x392 : (('i, 'o) facet -> Extension.t) option)
          () ->
        let x393 = Ojs.empty_obj () in
        Ojs.set_prop_ascii
          x393
          "combine"
          (Ojs.fun_to_js 1 (fun (x407 : Ojs.t) ->
             Obj.magic (x388 (Ojs.list_of_js Obj.magic x407))));
        (match x389 with
         | Some x404 ->
           Ojs.set_prop_ascii
             x393
             "compare"
             (Ojs.fun_to_js 2 (fun (x405 : Ojs.t) (x406 : Ojs.t) ->
                Ojs.bool_to_js (x404 (Obj.magic x405) (Obj.magic x406))))
         | None -> ());
        (match x390 with
         | Some x401 ->
           Ojs.set_prop_ascii
             x393
             "compareInput"
             (Ojs.fun_to_js 2 (fun (x402 : Ojs.t) (x403 : Ojs.t) ->
                Ojs.bool_to_js (x401 (Obj.magic x402) (Obj.magic x403))))
         | None -> ());
        (match x391 with
         | Some x400 -> Ojs.set_prop_ascii x393 "static" (Ojs.bool_to_js x400)
         | None -> ());
        (match x392 with
         | Some x396 ->
           Ojs.set_prop_ascii
             x393
             "enables"
             (Ojs.fun_to_js 1 (fun (x397 : Ojs.t) ->
                Extension.t_to_js (x396 (facet_of_js Obj.magic Obj.magic x397))))
         | None -> ());
        t_of_js Obj.magic Obj.magic x393
      ;;
    end

    let define : ('i, 'o) Config.t -> ('i, 'o) t =
      fun (x409 : ('i, 'o) Config.t) ->
      t_of_js
        Obj.magic
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Facet")
           "define"
           [| Config.t_to_js Obj.magic Obj.magic x409 |])
    ;;
  end

  module Char_category = struct
    type t =
      | Word
      | Space
      | Other

    let rec t_of_js : Ojs.t -> t =
      fun (x415 : Ojs.t) ->
      let x416 = x415 in
      match Ojs.string_of_js x416 with
      | "Word" -> Word
      | "Space" -> Space
      | "Other" -> Other
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x414 : t) ->
      match x414 with
      | Word -> Ojs.string_to_js "Word"
      | Space -> Ojs.string_to_js "Space"
      | Other -> Ojs.string_to_js "Other"
    ;;
  end

  module Change_filter_result = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x418 : Ojs.t) -> x418
    and t_to_js : t -> Ojs.t = fun (x417 : Ojs.t) -> x417

    let bool : bool -> t = fun (x419 : bool) -> t_of_js (Ojs.bool_to_js x419)

    let ranges : int list -> t =
      fun (x420 : int list) -> t_of_js (Ojs.list_to_js Ojs.int_to_js x420)
    ;;
  end

  module Transaction_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x423 : Ojs.t) -> x423
    and t_to_js : t -> Ojs.t = fun (x422 : Ojs.t) -> x422

    let create
      :  ?changes:Change_spec.t -> ?selection:Editor_selection.t
      -> ?effects:State_effect.t list -> ?annotations:Annotation.t list
      -> ?scroll_into_view:bool -> ?filter:bool -> ?sequential:bool -> unit -> t
      =
      fun ?changes:(x424 : Change_spec.t option)
        ?selection:(x425 : Editor_selection.t option)
        ?effects:(x426 : State_effect.t list option)
        ?annotations:(x427 : Annotation.t list option)
        ?scroll_into_view:(x428 : bool option)
        ?filter:(x429 : bool option)
        ?sequential:(x430 : bool option)
        () ->
      let x431 = Ojs.empty_obj () in
      (match x424 with
       | Some x440 -> Ojs.set_prop_ascii x431 "changes" (Change_spec.t_to_js x440)
       | None -> ());
      (match x425 with
       | Some x439 -> Ojs.set_prop_ascii x431 "selection" (Editor_selection.t_to_js x439)
       | None -> ());
      (match x426 with
       | Some x437 ->
         Ojs.set_prop_ascii x431 "effects" (Ojs.list_to_js State_effect.t_to_js x437)
       | None -> ());
      (match x427 with
       | Some x435 ->
         Ojs.set_prop_ascii x431 "annotations" (Ojs.list_to_js Annotation.t_to_js x435)
       | None -> ());
      (match x428 with
       | Some x434 -> Ojs.set_prop_ascii x431 "scrollIntoView" (Ojs.bool_to_js x434)
       | None -> ());
      (match x429 with
       | Some x433 -> Ojs.set_prop_ascii x431 "filter" (Ojs.bool_to_js x433)
       | None -> ());
      (match x430 with
       | Some x432 -> Ojs.set_prop_ascii x431 "sequential" (Ojs.bool_to_js x432)
       | None -> ());
      t_of_js x431
    ;;
  end

  module Compartment = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x442 : Ojs.t) -> x442
    and t_to_js : t -> Ojs.t = fun (x441 : Ojs.t) -> x441

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Compartment")
           [||])
    ;;

    let of_ : t -> Extension.t -> Extension.t =
      fun (x444 : t) (x443 : Extension.t) ->
      Extension.t_of_js (Ojs.call (t_to_js x444) "of" [| Extension.t_to_js x443 |])
    ;;

    let reconfigure : t -> Extension.t -> state_effect =
      fun (x446 : t) (x445 : Extension.t) ->
      state_effect_of_js
        (Ojs.call (t_to_js x446) "reconfigure" [| Extension.t_to_js x445 |])
    ;;

    let get : t -> editor_state -> Extension.t option =
      fun (x448 : t) (x447 : editor_state) ->
      Ojs.option_of_js
        Extension.t_of_js
        (Ojs.call (t_to_js x448) "get" [| editor_state_to_js x447 |])
    ;;
  end

  module Editor_state = struct
    type t = editor_state

    let rec t_of_js : Ojs.t -> t = fun (x451 : Ojs.t) -> editor_state_of_js x451
    and t_to_js : t -> Ojs.t = fun (x450 : editor_state) -> editor_state_to_js x450

    let doc : t -> Text.Text.t =
      fun (x452 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x452) "doc")
    ;;

    let selection : t -> Editor_selection.t =
      fun (x453 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x453) "selection")
    ;;

    let field : t -> 'a State_field.t -> 'a option =
      fun (x456 : t) (x454 : 'a State_field.t) ->
      Ojs.option_of_js
        Obj.magic
        (Ojs.call (t_to_js x456) "field" [| State_field.t_to_js Obj.magic x454 |])
    ;;

    let update : t -> Transaction_spec.t list -> Transaction.t =
      fun (x461 : t) (x458 : Transaction_spec.t list) ->
      Transaction.t_of_js
        (let x462 = t_to_js x461 in
         Ojs.call
           (Ojs.get_prop_ascii x462 "update")
           "apply"
           [| x462
            ; (let x459 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               List.iter
                 (fun (x460 : Transaction_spec.t) ->
                   ignore (Ojs.call x459 "push" [| Transaction_spec.t_to_js x460 |]))
                 x458;
               x459)
           |])
    ;;

    let replace_selection : t -> Text.Text.t -> Transaction_spec.t =
      fun (x464 : t) (x463 : Text.Text.t) ->
      Transaction_spec.t_of_js
        (Ojs.call (t_to_js x464) "replaceSelection" [| Text.Text.t_to_js x463 |])
    ;;

    let change_by_range
      : t -> f:(Selection_range.t -> Transaction_spec.t) -> Transaction_spec.t
      =
      fun (x467 : t) ~f:(x465 : Selection_range.t -> Transaction_spec.t) ->
      Transaction_spec.t_of_js
        (Ojs.call
           (t_to_js x467)
           "changeByRange"
           [| Ojs.fun_to_js 1 (fun (x466 : Ojs.t) ->
                Transaction_spec.t_to_js (x465 (Selection_range.t_of_js x466)))
           |])
    ;;

    let changes : t -> Change_spec.t -> Change_set.t =
      fun (x469 : t) (x468 : Change_spec.t) ->
      Change_set.t_of_js
        (Ojs.call (t_to_js x469) "changes" [| Change_spec.t_to_js x468 |])
    ;;

    let to_text : t -> string -> Text.Text.t =
      fun (x471 : t) (x470 : string) ->
      Text.Text.t_of_js (Ojs.call (t_to_js x471) "toText" [| Ojs.string_to_js x470 |])
    ;;

    let slice_doc : t -> ?from:int -> ?to_:int -> unit -> string =
      fun (x477 : t) ?from:(x472 : int option) ?to_:(x473 : int option) () ->
      Ojs.string_of_js
        (let x478 = t_to_js x477 in
         Ojs.call
           (Ojs.get_prop_ascii x478 "sliceDoc")
           "apply"
           [| x478
            ; (let x474 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x472 with
                | Some x476 -> ignore (Ojs.call x474 "push" [| Ojs.int_to_js x476 |])
                | None -> ());
               (match x473 with
                | Some x475 -> ignore (Ojs.call x474 "push" [| Ojs.int_to_js x475 |])
                | None -> ());
               x474)
           |])
    ;;

    let facet : t -> ('i, 'o) Facet.t -> 'o =
      fun (x482 : t) (x479 : ('i, 'o) Facet.t) ->
      Obj.magic
        (Ojs.call (t_to_js x482) "facet" [| Facet.t_to_js Obj.magic Obj.magic x479 |])
    ;;

    let to_json : t -> Ojs.t = fun (x483 : t) -> Ojs.call (t_to_js x483) "toJSON" [||]

    let get_tab_size : t -> int =
      fun (x484 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x484) "tabSize")
    ;;

    let line_break : t -> string =
      fun (x485 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x485) "lineBreak")
    ;;

    let phrase : t -> string -> string =
      fun (x487 : t) (x486 : string) ->
      Ojs.string_of_js (Ojs.call (t_to_js x487) "phrase" [| Ojs.string_to_js x486 |])
    ;;

    let language_data_at : t -> name:string -> pos:int -> Ojs.t list =
      fun (x490 : t) ~name:(x488 : string) ~pos:(x489 : int) ->
      Ojs.list_of_js
        (fun (x491 : Ojs.t) -> x491)
        (Ojs.call
           (t_to_js x490)
           "languageDataAt"
           [| Ojs.string_to_js x488; Ojs.int_to_js x489 |])
    ;;

    let char_categorizer : t -> int -> string -> Char_category.t =
      fun (x494 : t) (x492 : int) (x493 : string) ->
      Char_category.t_of_js
        (Ojs.call
           (t_to_js x494)
           "charCategorizer"
           [| Ojs.int_to_js x492; Ojs.string_to_js x493 |])
    ;;

    let from_json
      : json:Ojs.t -> ?config:Editor_state_config.t -> ?fields:Ojs.t -> unit -> t
      =
      fun ~json:(x495 : Ojs.t)
        ?config:(x496 : Editor_state_config.t option)
        ?fields:(x497 : Ojs.t option)
        () ->
      t_of_js
        (let x501 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorState"
         in
         Ojs.call
           (Ojs.get_prop_ascii x501 "fromJSON")
           "apply"
           [| x501
            ; (let x498 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x498 "push" [| x495 |]);
               (match x496 with
                | Some x500 ->
                  ignore (Ojs.call x498 "push" [| Editor_state_config.t_to_js x500 |])
                | None -> ());
               (match x497 with
                | Some x499 -> ignore (Ojs.call x498 "push" [| x499 |])
                | None -> ());
               x498)
           |])
    ;;

    let create : Editor_state_config.t -> t =
      fun (x502 : Editor_state_config.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "create"
           [| Editor_state_config.t_to_js x502 |])
    ;;

    let allow_multiple_selections : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "allowMultipleSelections")
    ;;

    let tab_size : (int, int) Facet.t =
      Facet.t_of_js
        Ojs.int_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "tabSize")
    ;;

    let read_only : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "readOnly")
    ;;

    let line_separator : (string, string option) Facet.t =
      Facet.t_of_js
        Ojs.string_of_js
        (fun (x510 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x510)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "lineSeparator")
    ;;

    let phrases : Ojs.t Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x512 : Ojs.t) -> x512)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "phrases")
    ;;

    let language_data : (t -> int -> Ojs.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x513 : Ojs.t) (x514 : t) (x515 : int) ->
          Ojs.list_of_js
            (fun (x516 : Ojs.t) -> x516)
            (Ojs.apply x513 [| t_to_js x514; Ojs.int_to_js x515 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "languageData")
    ;;

    let change_filter : (Transaction.t -> Change_filter_result.t) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x517 : Ojs.t) (x518 : Transaction.t) ->
          Change_filter_result.t_of_js (Ojs.apply x517 [| Transaction.t_to_js x518 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "changeFilter")
    ;;

    let transaction_filter : (Transaction.t -> Transaction_spec.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x519 : Ojs.t) (x520 : Transaction.t) ->
          Ojs.list_of_js
            Transaction_spec.t_of_js
            (Ojs.apply x519 [| Transaction.t_to_js x520 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionFilter")
    ;;

    let transaction_extender : (Transaction.t -> Effects_and_annotation.t) Facet.multi_out
      =
      Facet.multi_out_of_js
        (fun (x522 : Ojs.t) (x523 : Transaction.t) ->
          Effects_and_annotation.t_of_js (Ojs.apply x522 [| Transaction.t_to_js x523 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionExtender")
    ;;
  end

  module Range = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x525 : Ojs.t) -> x525

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x524 : Ojs.t) -> x524
    ;;

    let from : 'v t -> int =
      fun (x526 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x526) "from")
    ;;

    let to_ : 'v t -> int =
      fun (x528 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x528) "to")
    ;;
  end

  module Range_set_update_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x531 : Ojs.t) -> x531

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x530 : Ojs.t) -> x530
    ;;

    let create
      :  add:'v Range.t list -> sort:bool
      -> filter:(from:int -> to_:int -> value:'v -> bool) option -> filter_from:int option
      -> filter_to:int option -> 'v t
      =
      fun ~add:(x532 : 'v Range.t list)
        ~sort:(x533 : bool)
        ~filter:(x534 : (from:int -> to_:int -> value:'v -> bool) option)
        ~filter_from:(x535 : int option)
        ~filter_to:(x536 : int option) ->
      let x537 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x537
        "add"
        (Ojs.list_to_js (fun (x545 : 'v Range.t) -> Range.t_to_js Obj.magic x545) x532);
      Ojs.set_prop_ascii x537 "sort" (Ojs.bool_to_js x533);
      Ojs.set_prop_ascii
        x537
        "filter"
        (Ojs.option_to_js
           (fun (x541 : from:int -> to_:int -> value:'v -> bool) ->
             Ojs.fun_to_js 3 (fun (x542 : Ojs.t) (x543 : Ojs.t) (x544 : Ojs.t) ->
               Ojs.bool_to_js
                 (x541
                    ~from:(Ojs.int_of_js x542)
                    ~to_:(Ojs.int_of_js x543)
                    ~value:(Obj.magic x544))))
           x534);
      Ojs.set_prop_ascii x537 "filterFrom" (Ojs.option_to_js Ojs.int_to_js x535);
      Ojs.set_prop_ascii x537 "filterTo" (Ojs.option_to_js Ojs.int_to_js x536);
      t_of_js Obj.magic x537
    ;;
  end

  module Range_set = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x548 : Ojs.t) -> x548

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x547 : Ojs.t) -> x547
    ;;

    let empty : 'v t =
      t_of_js
        Obj.magic
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "RangeSet")
           "empty")
    ;;

    let size : 'v t -> int =
      fun (x550 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x550) "size")
    ;;

    let update : 'v t -> update_spec:'v Range_set_update_spec.t -> 'v t =
      fun (x554 : 'v t) ~update_spec:(x552 : 'v Range_set_update_spec.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (t_to_js Obj.magic x554)
           "update"
           [| Range_set_update_spec.t_to_js Obj.magic x552 |])
    ;;

    let between
      :  'v t -> from:int -> to_:int -> f:(from:int -> to_:int -> value:'v -> bool option)
      -> unit
      =
      fun (x564 : 'v t)
        ~from:(x557 : int)
        ~to_:(x558 : int)
        ~f:(x559 : from:int -> to_:int -> value:'v -> bool option) ->
      ignore
        (Ojs.call
           (t_to_js Obj.magic x564)
           "between"
           [| Ojs.int_to_js x557
            ; Ojs.int_to_js x558
            ; Ojs.fun_to_js 3 (fun (x560 : Ojs.t) (x561 : Ojs.t) (x562 : Ojs.t) ->
                Ojs.option_to_js
                  Ojs.bool_to_js
                  (x559
                     ~from:(Ojs.int_of_js x560)
                     ~to_:(Ojs.int_of_js x561)
                     ~value:(Obj.magic x562)))
           |])
    ;;
  end

  module Prec = struct
    let fallback : Extension.t -> Extension.t =
      fun (x566 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "fallback"
           [| Extension.t_to_js x566 |])
    ;;

    let default : Extension.t -> Extension.t =
      fun (x567 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "default"
           [| Extension.t_to_js x567 |])
    ;;

    let extend : Extension.t -> Extension.t =
      fun (x568 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "extend"
           [| Extension.t_to_js x568 |])
    ;;

    let override : Extension.t -> Extension.t =
      fun (x569 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "override"
           [| Extension.t_to_js x569 |])
    ;;

    let high : Extension.t -> Extension.t =
      fun (x570 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "high"
           [| Extension.t_to_js x570 |])
    ;;
  end
end

module View = struct
  type editor_view = Ojs.t

  let rec editor_view_of_js : Ojs.t -> editor_view = fun (x572 : Ojs.t) -> x572
  and editor_view_to_js : editor_view -> Ojs.t = fun (x571 : Ojs.t) -> x571

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x574 : Ojs.t) -> x574
    and t_to_js : t -> Ojs.t = fun (x573 : Ojs.t) -> x573

    let create
      :  ?state:State.Editor_state.t
      -> ?dispatch:(State.Transaction.t -> editor_view -> unit) Callback.t
      -> ?scroll_to:State.State_effect.t -> unit -> t
      =
      fun ?state:(x575 : State.Editor_state.t option)
        ?dispatch:(x576 : (State.Transaction.t -> editor_view -> unit) Callback.t option)
        ?scroll_to:(x577 : State.State_effect.t option)
        () ->
      let x578 = Ojs.empty_obj () in
      (match x575 with
       | Some x584 -> Ojs.set_prop_ascii x578 "state" (State.Editor_state.t_to_js x584)
       | None -> ());
      (match x576 with
       | Some x580 ->
         Ojs.set_prop_ascii
           x578
           "dispatch"
           (Callback.t_to_js
              (fun (x581 : State.Transaction.t -> editor_view -> unit) ->
                Ojs.fun_to_js 2 (fun (x582 : Ojs.t) (x583 : Ojs.t) ->
                  x581 (State.Transaction.t_of_js x582) (editor_view_of_js x583)))
              x580)
       | None -> ());
      (match x577 with
       | Some x579 -> Ojs.set_prop_ascii x578 "scrollTo" (State.State_effect.t_to_js x579)
       | None -> ());
      t_of_js x578
    ;;
  end

  module View_update = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x586 : Ojs.t) -> x586
    and t_to_js : t -> Ojs.t = fun (x585 : Ojs.t) -> x585

    let changes : t -> State.Change_set.t =
      fun (x587 : t) ->
      State.Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x587) "changes")
    ;;

    let transactions : t -> State.Transaction.t list =
      fun (x588 : t) ->
      Ojs.list_of_js
        State.Transaction.t_of_js
        (Ojs.get_prop_ascii (t_to_js x588) "transactions")
    ;;

    let state : t -> State.Editor_state.t =
      fun (x590 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x590) "state")
    ;;

    let view : t -> editor_view =
      fun (x591 : t) -> editor_view_of_js (Ojs.get_prop_ascii (t_to_js x591) "view")
    ;;

    let viewport_changed : t -> bool =
      fun (x592 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x592) "viewportChanged")
    ;;

    let doc_changed : t -> bool =
      fun (x593 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x593) "docChanged")
    ;;

    let focus_changed : t -> bool =
      fun (x594 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x594) "focusChanged")
    ;;
  end

  let highlight_special_chars : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightSpecialChars"
         [||])
  ;;

  let highlight_active_line : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLine"
         [||])
  ;;

  let placeholder : content:string -> State.Extension.t =
    fun ~content:(x595 : string) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "placeholder"
         [| Ojs.string_to_js x595 |])
  ;;

  module Draw_selection_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x597 : Ojs.t) -> x597
    and t_to_js : t -> Ojs.t = fun (x596 : Ojs.t) -> x596

    let create : ?cursor_blink_rate:float -> ?draw_range_cursor:bool -> unit -> t =
      fun ?cursor_blink_rate:(x598 : float option)
        ?draw_range_cursor:(x599 : bool option)
        () ->
      let x600 = Ojs.empty_obj () in
      (match x598 with
       | Some x602 -> Ojs.set_prop_ascii x600 "cursorBlinkRate" (Ojs.float_to_js x602)
       | None -> ());
      (match x599 with
       | Some x601 -> Ojs.set_prop_ascii x600 "drawRangeCursor" (Ojs.bool_to_js x601)
       | None -> ());
      t_of_js x600
    ;;
  end

  let draw_selection : ?config:Draw_selection_config.t -> unit -> State.Extension.t =
    fun ?config:(x603 : Draw_selection_config.t option) () ->
    State.Extension.t_of_js
      (let x606 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x606 "drawSelection")
         "apply"
         [| x606
          ; (let x604 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x603 with
              | Some x605 ->
                ignore (Ojs.call x604 "push" [| Draw_selection_config.t_to_js x605 |])
              | None -> ());
             x604)
         |])
  ;;

  module Widget_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x608 : Ojs.t) -> x608
    and t_to_js : t -> Ojs.t = fun (x607 : Ojs.t) -> x607

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "WidgetType")
           [||])
    ;;

    let set_to_dom : t -> (unit -> Ojs.t) -> unit =
      fun (x609 : t) (x610 : unit -> Ojs.t) ->
      Ojs.set_prop_ascii (t_to_js x609) "toDOM" (Ojs.fun_to_js 1 (fun _ -> x610 ()))
    ;;
  end

  module Decoration = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x612 : Ojs.t) -> x612
    and t_to_js : t -> Ojs.t = fun (x611 : Ojs.t) -> x611

    let range : t -> from:int -> to_:int -> t State.Range.t =
      fun (x615 : t) ~from:(x613 : int) ~to_:(x614 : int) ->
      State.Range.t_of_js
        t_of_js
        (Ojs.call (t_to_js x615) "range" [| Ojs.int_to_js x613; Ojs.int_to_js x614 |])
    ;;

    let set : t State.Range.t list -> sort:bool -> t State.Range_set.t =
      fun (x617 : t State.Range.t list) ~sort:(x620 : bool) ->
      State.Range_set.t_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "set"
           [| Ojs.list_to_js
                (fun (x618 : t State.Range.t) -> State.Range.t_to_js t_to_js x618)
                x617
            ; Ojs.bool_to_js x620
           |])
    ;;

    let none : t State.Range_set.t =
      State.Range_set.t_of_js
        t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "none")
    ;;

    module Mark_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x624 : Ojs.t) -> x624
      and t_to_js : t -> Ojs.t = fun (x623 : Ojs.t) -> x623

      let create
        :  ?inclusive:bool -> ?inclusive_start:bool -> ?inclusive_end:bool
        -> ?attributes:Ojs.t -> ?class_:string -> ?tag_name:string -> unit -> t
        =
        fun ?inclusive:(x625 : bool option)
          ?inclusive_start:(x626 : bool option)
          ?inclusive_end:(x627 : bool option)
          ?attributes:(x628 : Ojs.t option)
          ?class_:(x629 : string option)
          ?tag_name:(x630 : string option)
          () ->
        let x631 = Ojs.empty_obj () in
        (match x625 with
         | Some x637 -> Ojs.set_prop_ascii x631 "inclusive" (Ojs.bool_to_js x637)
         | None -> ());
        (match x626 with
         | Some x636 -> Ojs.set_prop_ascii x631 "inclusiveStart" (Ojs.bool_to_js x636)
         | None -> ());
        (match x627 with
         | Some x635 -> Ojs.set_prop_ascii x631 "inclusiveEnd" (Ojs.bool_to_js x635)
         | None -> ());
        (match x628 with
         | Some x634 -> Ojs.set_prop_ascii x631 "attributes" x634
         | None -> ());
        (match x629 with
         | Some x633 -> Ojs.set_prop_ascii x631 "class" (Ojs.string_to_js x633)
         | None -> ());
        (match x630 with
         | Some x632 -> Ojs.set_prop_ascii x631 "tagName" (Ojs.string_to_js x632)
         | None -> ());
        t_of_js x631
      ;;
    end

    let mark : Mark_spec.t -> t =
      fun (x638 : Mark_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "mark"
           [| Mark_spec.t_to_js x638 |])
    ;;

    module Widget_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x640 : Ojs.t) -> x640
      and t_to_js : t -> Ojs.t = fun (x639 : Ojs.t) -> x639

      let create
        :  widget:Widget_type.t -> ?side:int -> ?inline_order:bool -> ?block:bool -> unit
        -> t
        =
        fun ~widget:(x641 : Widget_type.t)
          ?side:(x642 : int option)
          ?inline_order:(x643 : bool option)
          ?block:(x644 : bool option)
          () ->
        let x645 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x645 "widget" (Widget_type.t_to_js x641);
        (match x642 with
         | Some x648 -> Ojs.set_prop_ascii x645 "side" (Ojs.int_to_js x648)
         | None -> ());
        (match x643 with
         | Some x647 -> Ojs.set_prop_ascii x645 "inlineOrder" (Ojs.bool_to_js x647)
         | None -> ());
        (match x644 with
         | Some x646 -> Ojs.set_prop_ascii x645 "block" (Ojs.bool_to_js x646)
         | None -> ());
        t_of_js x645
      ;;
    end

    let widget : Widget_spec.t -> t =
      fun (x649 : Widget_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "widget"
           [| Widget_spec.t_to_js x649 |])
    ;;

    module Replace_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x651 : Ojs.t) -> x651
      and t_to_js : t -> Ojs.t = fun (x650 : Ojs.t) -> x650

      let create
        :  ?widget:Widget_type.t -> ?inclusive:bool -> ?inclusive_start:bool
        -> ?inclusive_end:bool -> ?block:bool -> unit -> t
        =
        fun ?widget:(x652 : Widget_type.t option)
          ?inclusive:(x653 : bool option)
          ?inclusive_start:(x654 : bool option)
          ?inclusive_end:(x655 : bool option)
          ?block:(x656 : bool option)
          () ->
        let x657 = Ojs.empty_obj () in
        (match x652 with
         | Some x662 -> Ojs.set_prop_ascii x657 "widget" (Widget_type.t_to_js x662)
         | None -> ());
        (match x653 with
         | Some x661 -> Ojs.set_prop_ascii x657 "inclusive" (Ojs.bool_to_js x661)
         | None -> ());
        (match x654 with
         | Some x660 -> Ojs.set_prop_ascii x657 "inclusiveStart" (Ojs.bool_to_js x660)
         | None -> ());
        (match x655 with
         | Some x659 -> Ojs.set_prop_ascii x657 "inclusiveEnd" (Ojs.bool_to_js x659)
         | None -> ());
        (match x656 with
         | Some x658 -> Ojs.set_prop_ascii x657 "block" (Ojs.bool_to_js x658)
         | None -> ());
        t_of_js x657
      ;;
    end

    let replace : Replace_spec.t -> t =
      fun (x663 : Replace_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "replace"
           [| Replace_spec.t_to_js x663 |])
    ;;

    module Line_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x665 : Ojs.t) -> x665
      and t_to_js : t -> Ojs.t = fun (x664 : Ojs.t) -> x664

      let create : ?attributes:Ojs.t -> ?class_:string -> unit -> t =
        fun ?attributes:(x666 : Ojs.t option) ?class_:(x667 : string option) () ->
        let x668 = Ojs.empty_obj () in
        (match x666 with
         | Some x670 -> Ojs.set_prop_ascii x668 "attributes" x670
         | None -> ());
        (match x667 with
         | Some x669 -> Ojs.set_prop_ascii x668 "class" (Ojs.string_to_js x669)
         | None -> ());
        t_of_js x668
      ;;
    end

    let line : Line_spec.t -> t =
      fun (x671 : Line_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "line"
           [| Line_spec.t_to_js x671 |])
    ;;
  end

  module Decoration_set = struct
    type t = Decoration.t State.Range_set.t

    let rec t_of_js : Ojs.t -> t =
      fun (x674 : Ojs.t) -> State.Range_set.t_of_js Decoration.t_of_js x674

    and t_to_js : t -> Ojs.t =
      fun (x672 : Decoration.t State.Range_set.t) ->
      State.Range_set.t_to_js Decoration.t_to_js x672
    ;;
  end

  module Editor_view = struct
    type t = editor_view

    let rec t_of_js : Ojs.t -> t = fun (x677 : Ojs.t) -> editor_view_of_js x677
    and t_to_js : t -> Ojs.t = fun (x676 : editor_view) -> editor_view_to_js x676

    let create : Config.t -> t =
      fun (x678 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           [| Config.t_to_js x678 |])
    ;;

    let dom : t -> Dom_html_element.t =
      fun (x679 : t) -> Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x679) "dom")
    ;;

    let content_dom : t -> Dom_html_element.t =
      fun (x680 : t) ->
      Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x680) "contentDOM")
    ;;

    let update_listener : (View_update.t -> unit) State.Facet.multi_out =
      State.Facet.multi_out_of_js
        (fun (x681 : Ojs.t) (x682 : View_update.t) ->
          ignore (Ojs.apply x681 [| View_update.t_to_js x682 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "updateListener")
    ;;

    let update : t -> State.Transaction.t list -> unit =
      fun (x685 : t) (x683 : State.Transaction.t list) ->
      ignore
        (Ojs.call
           (t_to_js x685)
           "update"
           [| Ojs.list_to_js State.Transaction.t_to_js x683 |])
    ;;

    let dispatch : t -> State.Transaction.t -> unit =
      fun (x687 : t) (x686 : State.Transaction.t) ->
      ignore (Ojs.call (t_to_js x687) "dispatch" [| State.Transaction.t_to_js x686 |])
    ;;

    let dispatch_specs : t -> State.Transaction_spec.t -> unit =
      fun (x689 : t) (x688 : State.Transaction_spec.t) ->
      ignore
        (Ojs.call (t_to_js x689) "dispatch" [| State.Transaction_spec.t_to_js x688 |])
    ;;

    let set_state : t -> State.Editor_state.t -> unit =
      fun (x691 : t) (x690 : State.Editor_state.t) ->
      ignore (Ojs.call (t_to_js x691) "setState" [| State.Editor_state.t_to_js x690 |])
    ;;

    let state : t -> State.Editor_state.t =
      fun (x692 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x692) "state")
    ;;

    let focus : t -> unit =
      fun (x693 : t) -> ignore (Ojs.call (t_to_js x693) "focus" [||])
    ;;

    let has_focus : t -> bool =
      fun (x694 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x694) "hasFocus")
    ;;

    let destroy : t -> unit =
      fun (x695 : t) -> ignore (Ojs.call (t_to_js x695) "destroy" [||])
    ;;

    let line_wrapping : State.Extension.t =
      State.Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "lineWrapping")
    ;;

    let editable : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "editable")
    ;;

    let dark_theme : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "darkTheme")
    ;;

    let decorations : (Decoration_set.t, Decoration_set.t) State.Facet.t =
      State.Facet.t_of_js
        Decoration_set.t_of_js
        Decoration_set.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let decorations'
      : ( (editor_view -> Decoration_set.t) Callback.t
          , (editor_view -> Decoration_set.t) Callback.t )
          State.Facet.t
      =
      State.Facet.t_of_js
        (fun (x702 : Ojs.t) ->
          Callback.t_of_js
            (fun (x703 : Ojs.t) (x704 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x703 [| editor_view_to_js x704 |]))
            x702)
        (fun (x705 : Ojs.t) ->
          Callback.t_of_js
            (fun (x706 : Ojs.t) (x707 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x706 [| editor_view_to_js x707 |]))
            x705)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    module Viewport = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x709 : Ojs.t) -> x709
      and t_to_js : t -> Ojs.t = fun (x708 : Ojs.t) -> x708

      let from : t -> int =
        fun (x710 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x710) "from")
      ;;

      let to_ : t -> int =
        fun (x711 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x711) "to")
      ;;
    end

    let viewport : t -> Viewport.t =
      fun (x712 : t) -> Viewport.t_of_js (Ojs.get_prop_ascii (t_to_js x712) "viewport")
    ;;

    module Scroll_into_view_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x714 : Ojs.t) -> x714
      and t_to_js : t -> Ojs.t = fun (x713 : Ojs.t) -> x713

      let create : ?y:string -> unit -> t =
        fun ?y:(x715 : string option) () ->
        let x716 = Ojs.empty_obj () in
        (match x715 with
         | Some x717 -> Ojs.set_prop_ascii x716 "y" (Ojs.string_to_js x717)
         | None -> ());
        t_of_js x716
      ;;
    end

    let scroll_into_view
      : pos:int -> ?options:Scroll_into_view_options.t -> unit -> State.State_effect.t
      =
      fun ~pos:(x718 : int) ?options:(x719 : Scroll_into_view_options.t option) () ->
      State.State_effect.t_of_js
        (let x722 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x722 "scrollIntoView")
           "apply"
           [| x722
            ; (let x720 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x720 "push" [| Ojs.int_to_js x718 |]);
               (match x719 with
                | Some x721 ->
                  ignore
                    (Ojs.call x720 "push" [| Scroll_into_view_options.t_to_js x721 |])
                | None -> ());
               x720)
           |])
    ;;

    module Theme_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x724 : Ojs.t) -> x724
      and t_to_js : t -> Ojs.t = fun (x723 : Ojs.t) -> x723

      let create : ?dark:bool -> unit -> t =
        fun ?dark:(x725 : bool option) () ->
        let x726 = Ojs.empty_obj () in
        (match x725 with
         | Some x727 -> Ojs.set_prop_ascii x726 "dark" (Ojs.bool_to_js x727)
         | None -> ());
        t_of_js x726
      ;;
    end

    let theme : spec:Ojs.t -> ?options:Theme_options.t -> unit -> State.Extension.t =
      fun ~spec:(x728 : Ojs.t) ?options:(x729 : Theme_options.t option) () ->
      State.Extension.t_of_js
        (let x732 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x732 "theme")
           "apply"
           [| x732
            ; (let x730 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x730 "push" [| x728 |]);
               (match x729 with
                | Some x731 ->
                  ignore (Ojs.call x730 "push" [| Theme_options.t_to_js x731 |])
                | None -> ());
               x730)
           |])
    ;;
  end

  module Plugin_value = struct
    type 'v t =
      { update : (View_update.t -> unit) option
      ; custom_state : 'v
      }

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x736 : Ojs.t) ->
      { update =
          Ojs.option_of_js
            (fun (x737 : Ojs.t) (x738 : View_update.t) ->
              ignore (Ojs.apply x737 [| View_update.t_to_js x738 |]))
            (Ojs.get_prop_ascii x736 "update")
      ; custom_state = __v_of_js (Ojs.get_prop_ascii x736 "customState")
      }

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x733 : __v t) ->
      Ojs.obj
        [| ( "update"
           , Ojs.option_to_js
               (fun (x734 : View_update.t -> unit) ->
                 Ojs.fun_to_js 1 (fun (x735 : Ojs.t) -> x734 (View_update.t_of_js x735)))
               x733.update )
         ; "customState", __v_to_js x733.custom_state
        |]
    ;;
  end

  module Plugin_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x740 : Ojs.t) -> x740

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x739 : Ojs.t) -> x739
    ;;

    let create : decorations:('v Plugin_value.t -> Decoration_set.t) option -> 'v t =
      fun ~decorations:(x741 : ('v Plugin_value.t -> Decoration_set.t) option) ->
      let x742 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x742
        "decorations"
        (Ojs.option_to_js
           (fun (x744 : 'v Plugin_value.t -> Decoration_set.t) ->
             Ojs.fun_to_js 1 (fun (x745 : Ojs.t) ->
               Decoration_set.t_to_js (x744 (Plugin_value.t_of_js Obj.magic x745))))
           x741);
      t_of_js Obj.magic x742
    ;;
  end

  module View_plugin = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x748 : Ojs.t) -> x748

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x747 : Ojs.t) -> x747
    ;;

    let extension : 'v t -> State.Extension.t =
      fun (x749 : 'v t) ->
      State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x749) "extension")
    ;;

    let define
      :  create:(Editor_view.t -> 'v Plugin_value.t) -> ?spec:'v Plugin_spec.t -> unit
      -> 'v t
      =
      fun ~create:(x751 : Editor_view.t -> 'v Plugin_value.t)
        ?spec:(x752 : 'v Plugin_spec.t option)
        () ->
      t_of_js
        Obj.magic
        (let x758 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "ViewPlugin"
         in
         Ojs.call
           (Ojs.get_prop_ascii x758 "define")
           "apply"
           [| x758
            ; (let x753 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore
                 (Ojs.call
                    x753
                    "push"
                    [| Ojs.fun_to_js 1 (fun (x756 : Ojs.t) ->
                         Plugin_value.t_to_js Obj.magic (x751 (Editor_view.t_of_js x756)))
                    |]);
               (match x752 with
                | Some x754 ->
                  ignore (Ojs.call x753 "push" [| Plugin_spec.t_to_js Obj.magic x754 |])
                | None -> ());
               x753)
           |])
    ;;
  end

  module Match_decorator = struct
    module Config = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x761 : Ojs.t) -> x761
      and t_to_js : t -> Ojs.t = fun (x760 : Ojs.t) -> x760

      let create
        :  regexp:RegExp.t -> ?decoration:Decoration.t
        -> ?decorate:
             (add:(from:int -> to_:int -> Decoration.t -> unit)
              -> from:int
              -> to_:int
              -> string option list
              -> Editor_view.t
              -> unit)
        -> ?max_length:int -> unit -> t
        =
        fun ~regexp:(x762 : RegExp.t)
          ?decoration:(x763 : Decoration.t option)
          ?decorate:
            (x764 :
               (add:(from:int -> to_:int -> Decoration.t -> unit)
                -> from:int
                -> to_:int
                -> string option list
                -> Editor_view.t
                -> unit)
                 option)
          ?max_length:(x765 : int option)
          () ->
        let x766 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x766 "regexp" (RegExp.t_to_js x762);
        (match x763 with
         | Some x779 -> Ojs.set_prop_ascii x766 "decoration" (Decoration.t_to_js x779)
         | None -> ());
        (match x764 with
         | Some x768 ->
           Ojs.set_prop_ascii
             x766
             "decorate"
             (Ojs.fun_to_js
                5
                (fun
                    (x769 : Ojs.t)
                    (x773 : Ojs.t)
                    (x774 : Ojs.t)
                    (x775 : Ojs.t)
                    (x778 : Ojs.t)
                  ->
                   x768
                     ~add:
                       (fun
                         ~from:(x770 : int) ~to_:(x771 : int) (x772 : Decoration.t) ->
                       ignore
                         (Ojs.apply
                            x769
                            [| Ojs.int_to_js x770
                             ; Ojs.int_to_js x771
                             ; Decoration.t_to_js x772
                            |]))
                     ~from:(Ojs.int_of_js x773)
                     ~to_:(Ojs.int_of_js x774)
                     (Ojs.list_of_js
                        (fun (x776 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x776)
                        x775)
                     (Editor_view.t_of_js x778)))
         | None -> ());
        (match x765 with
         | Some x767 -> Ojs.set_prop_ascii x766 "maxLength" (Ojs.int_to_js x767)
         | None -> ());
        t_of_js x766
      ;;
    end

    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x781 : Ojs.t) -> x781
    and t_to_js : t -> Ojs.t = fun (x780 : Ojs.t) -> x780

    let create : Config.t -> t =
      fun (x782 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "MatchDecorator")
           [| Config.t_to_js x782 |])
    ;;

    let create_deco : t -> Editor_view.t -> Decoration_set.t =
      fun (x784 : t) (x783 : Editor_view.t) ->
      Decoration_set.t_of_js
        (Ojs.call (t_to_js x784) "createDeco" [| Editor_view.t_to_js x783 |])
    ;;
  end

  module Command = struct
    type t = Editor_view.t -> bool

    let rec t_of_js : Ojs.t -> t =
      fun (x787 : Ojs.t) (x788 : Editor_view.t) ->
      Ojs.bool_of_js (Ojs.apply x787 [| Editor_view.t_to_js x788 |])

    and t_to_js : t -> Ojs.t =
      fun (x785 : Editor_view.t -> bool) ->
      Ojs.fun_to_js 1 (fun (x786 : Ojs.t) ->
        Ojs.bool_to_js (x785 (Editor_view.t_of_js x786)))
    ;;
  end

  module Key_binding = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x790 : Ojs.t) -> x790
    and t_to_js : t -> Ojs.t = fun (x789 : Ojs.t) -> x789

    let create
      :  ?key:string -> ?mac:string -> ?win:string -> ?linux:string -> run:Command.t
      -> ?shift:Command.t -> ?scope:string -> ?prevent_default:bool -> unit -> t
      =
      fun ?key:(x791 : string option)
        ?mac:(x792 : string option)
        ?win:(x793 : string option)
        ?linux:(x794 : string option)
        ~run:(x795 : Command.t)
        ?shift:(x796 : Command.t option)
        ?scope:(x797 : string option)
        ?prevent_default:(x798 : bool option)
        () ->
      let x799 = Ojs.empty_obj () in
      (match x791 with
       | Some x806 -> Ojs.set_prop_ascii x799 "key" (Ojs.string_to_js x806)
       | None -> ());
      (match x792 with
       | Some x805 -> Ojs.set_prop_ascii x799 "mac" (Ojs.string_to_js x805)
       | None -> ());
      (match x793 with
       | Some x804 -> Ojs.set_prop_ascii x799 "win" (Ojs.string_to_js x804)
       | None -> ());
      (match x794 with
       | Some x803 -> Ojs.set_prop_ascii x799 "linux" (Ojs.string_to_js x803)
       | None -> ());
      Ojs.set_prop_ascii x799 "run" (Command.t_to_js x795);
      (match x796 with
       | Some x802 -> Ojs.set_prop_ascii x799 "shift" (Command.t_to_js x802)
       | None -> ());
      (match x797 with
       | Some x801 -> Ojs.set_prop_ascii x799 "scope" (Ojs.string_to_js x801)
       | None -> ());
      (match x798 with
       | Some x800 -> Ojs.set_prop_ascii x799 "preventDefault" (Ojs.bool_to_js x800)
       | None -> ());
      t_of_js x799
    ;;
  end

  let keymap : Key_binding.t list State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x807 : Ojs.t) -> Ojs.list_of_js Key_binding.t_of_js x807)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "keymap")
  ;;
end

module Autocomplete = struct
  module Completion = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x810 : Ojs.t) -> x810
    and t_to_js : t -> Ojs.t = fun (x809 : Ojs.t) -> x809

    let create
      :  label:string -> ?detail:string
      -> ?info:[ `Str of string | `Dom of t -> Dom_html_element.t ] -> ?type_:string
      -> ?boost:int -> ?apply:string -> unit -> t
      =
      fun ~label:(x811 : string)
        ?detail:(x812 : string option)
        ?info:(x813 : [ `Str of string | `Dom of t -> Dom_html_element.t ] option)
        ?type_:(x814 : string option)
        ?boost:(x815 : int option)
        ?apply:(x816 : string option)
        () ->
      let x817 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x817 "label" (Ojs.string_to_js x811);
      (match x812 with
       | Some x825 -> Ojs.set_prop_ascii x817 "detail" (Ojs.string_to_js x825)
       | None -> ());
      (match x813 with
       | Some x821 ->
         Ojs.set_prop_ascii
           x817
           "info"
           (match x821 with
            | `Str x822 -> Ojs.string_to_js x822
            | `Dom x823 ->
              Ojs.fun_to_js 1 (fun (x824 : Ojs.t) ->
                Dom_html_element.t_to_js (x823 (t_of_js x824))))
       | None -> ());
      (match x814 with
       | Some x820 -> Ojs.set_prop_ascii x817 "type" (Ojs.string_to_js x820)
       | None -> ());
      (match x815 with
       | Some x819 -> Ojs.set_prop_ascii x817 "boost" (Ojs.int_to_js x819)
       | None -> ());
      (match x816 with
       | Some x818 -> Ojs.set_prop_ascii x817 "apply" (Ojs.string_to_js x818)
       | None -> ());
      t_of_js x817
    ;;

    let label : t -> string =
      fun (x826 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x826) "label")
    ;;

    let type_ : t -> string option =
      fun (x827 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x827) "type")
    ;;
  end

  module CompletionContext = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x830 : Ojs.t) -> x830
    and t_to_js : t -> Ojs.t = fun (x829 : Ojs.t) -> x829

    let state : t -> State.Editor_state.t =
      fun (x831 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x831) "state")
    ;;

    let pos : t -> int =
      fun (x832 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x832) "pos")
    ;;

    let explicit : t -> bool =
      fun (x833 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x833) "explicit")
    ;;
  end

  module CompletionResult = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x835 : Ojs.t) -> x835
    and t_to_js : t -> Ojs.t = fun (x834 : Ojs.t) -> x834

    let create
      :  from:int -> ?to_:int -> options:Completion.t list
      -> ?valid_for:
           [ `Regex of RegExp.t
           | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
           ]
      -> ?filter:bool -> unit -> t
      =
      fun ~from:(x836 : int)
        ?to_:(x837 : int option)
        ~options:(x838 : Completion.t list)
        ?valid_for:
          (x839 :
             [ `Regex of RegExp.t
             | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
             ]
               option)
        ?filter:(x840 : bool option)
        () ->
      let x841 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x841 "from" (Ojs.int_to_js x836);
      (match x837 with
       | Some x851 -> Ojs.set_prop_ascii x841 "to" (Ojs.int_to_js x851)
       | None -> ());
      Ojs.set_prop_ascii x841 "options" (Ojs.list_to_js Completion.t_to_js x838);
      (match x839 with
       | Some x843 ->
         Ojs.set_prop_ascii
           x841
           "validFor"
           (match x843 with
            | `Regex x844 -> RegExp.t_to_js x844
            | `Fn x845 ->
              Ojs.fun_to_js
                4
                (fun (x846 : Ojs.t) (x847 : Ojs.t) (x848 : Ojs.t) (x849 : Ojs.t) ->
                   Ojs.bool_to_js
                     (x845
                        (Ojs.string_of_js x846)
                        ~from:(Ojs.int_of_js x847)
                        ~to_:(Ojs.int_of_js x848)
                        (State.Editor_state.t_of_js x849))))
       | None -> ());
      (match x840 with
       | Some x842 -> Ojs.set_prop_ascii x841 "filter" (Ojs.bool_to_js x842)
       | None -> ());
      t_of_js x841
    ;;
  end

  module CompletionSource = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x853 : Ojs.t) -> x853
    and t_to_js : t -> Ojs.t = fun (x852 : Ojs.t) -> x852

    let of_sync_fun : (CompletionContext.t -> CompletionResult.t) -> t =
      fun (x854 : CompletionContext.t -> CompletionResult.t) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x855 : Ojs.t) ->
           CompletionResult.t_to_js (x854 (CompletionContext.t_of_js x855))))
    ;;

    let of_promise_fun
      : (CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) -> t
      =
      fun (x856 : CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x857 : Ojs.t) ->
           Ojs.option_to_js
             (fun (x858 : (CompletionResult.t, 'e) Promise.t) ->
               Promise.t_to_js CompletionResult.t_to_js Obj.magic x858)
             (x856 (CompletionContext.t_of_js x857))))
    ;;
  end

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x862 : Ojs.t) -> x862
    and t_to_js : t -> Ojs.t = fun (x861 : Ojs.t) -> x861

    module Add_to_options_parameters = struct
      type t =
        { render : Completion.t -> State.Editor_state.t -> Dom_html_element.t option
        ; position : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x867 : Ojs.t) ->
        { render =
            (fun (x868 : Completion.t) (x869 : State.Editor_state.t) ->
              Ojs.option_of_js
                Dom_html_element.t_of_js
                (Ojs.apply
                   (Ojs.get_prop_ascii x867 "render")
                   [| Completion.t_to_js x868; State.Editor_state.t_to_js x869 |]))
        ; position = Ojs.int_of_js (Ojs.get_prop_ascii x867 "position")
        }

      and t_to_js : t -> Ojs.t =
        fun (x863 : t) ->
        Ojs.obj
          [| ( "render"
             , Ojs.fun_to_js 2 (fun (x864 : Ojs.t) (x865 : Ojs.t) ->
                 Ojs.option_to_js
                   Dom_html_element.t_to_js
                   (x863.render
                      (Completion.t_of_js x864)
                      (State.Editor_state.t_of_js x865))) )
           ; "position", Ojs.int_to_js x863.position
          |]
      ;;
    end

    let create
      :  ?activate_on_typing:bool -> ?override:CompletionSource.t list
      -> ?max_rendered_options:int -> ?default_keymap:bool -> ?icons:bool
      -> ?add_to_options:Add_to_options_parameters.t list -> unit -> t
      =
      fun ?activate_on_typing:(x871 : bool option)
        ?override:(x872 : CompletionSource.t list option)
        ?max_rendered_options:(x873 : int option)
        ?default_keymap:(x874 : bool option)
        ?icons:(x875 : bool option)
        ?add_to_options:(x876 : Add_to_options_parameters.t list option)
        () ->
      let x877 = Ojs.empty_obj () in
      (match x871 with
       | Some x885 -> Ojs.set_prop_ascii x877 "activateOnTyping" (Ojs.bool_to_js x885)
       | None -> ());
      (match x872 with
       | Some x883 ->
         Ojs.set_prop_ascii x877 "override" (Ojs.list_to_js CompletionSource.t_to_js x883)
       | None -> ());
      (match x873 with
       | Some x882 -> Ojs.set_prop_ascii x877 "maxRenderedOptions" (Ojs.int_to_js x882)
       | None -> ());
      (match x874 with
       | Some x881 -> Ojs.set_prop_ascii x877 "defaultKeymap" (Ojs.bool_to_js x881)
       | None -> ());
      (match x875 with
       | Some x880 -> Ojs.set_prop_ascii x877 "icons" (Ojs.bool_to_js x880)
       | None -> ());
      (match x876 with
       | Some x878 ->
         Ojs.set_prop_ascii
           x877
           "addToOptions"
           (Ojs.list_to_js Add_to_options_parameters.t_to_js x878)
       | None -> ());
      t_of_js x877
    ;;
  end

  module Move_completion_selection_by = struct
    type t =
      | Option
      | Page

    let rec t_of_js : Ojs.t -> t =
      fun (x887 : Ojs.t) ->
      let x888 = x887 in
      match Ojs.string_of_js x888 with
      | "option" -> Option
      | "page" -> Page
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x886 : t) ->
      match x886 with
      | Option -> Ojs.string_to_js "option"
      | Page -> Ojs.string_to_js "page"
    ;;
  end

  let autocompletion : Config.t -> State.Extension.t =
    fun (x889 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "autocompletion"
         [| Config.t_to_js x889 |])
  ;;

  let completion_status : State.Editor_state.t -> string option =
    fun (x890 : State.Editor_state.t) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionStatus"
         [| State.Editor_state.t_to_js x890 |])
  ;;

  let start_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "startCompletion")
  ;;

  let close_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "closeCompletion")
  ;;

  let accept_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "acceptCompletion")
  ;;

  let move_completion_selection
    : forward:bool -> ?by:Move_completion_selection_by.t -> unit -> View.Command.t
    =
    fun ~forward:(x892 : bool) ?by:(x893 : Move_completion_selection_by.t option) () ->
    View.Command.t_of_js
      (let x896 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete"
       in
       Ojs.call
         (Ojs.get_prop_ascii x896 "moveCompletionSelection")
         "apply"
         [| x896
          ; (let x894 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore (Ojs.call x894 "push" [| Ojs.bool_to_js x892 |]);
             (match x893 with
              | Some x895 ->
                ignore
                  (Ojs.call x894 "push" [| Move_completion_selection_by.t_to_js x895 |])
              | None -> ());
             x894)
         |])
  ;;

  let completion_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionKeymap")
  ;;
end

module Lint = struct
  module Diagnostic = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x899 : Ojs.t) -> x899
    and t_to_js : t -> Ojs.t = fun (x898 : Ojs.t) -> x898

    module Severity = struct
      type t =
        | Error
        | Hint
        | Info
        | Warning

      let rec t_of_js : Ojs.t -> t =
        fun (x901 : Ojs.t) ->
        let x902 = x901 in
        match Ojs.string_of_js x902 with
        | "error" -> Error
        | "hint" -> Hint
        | "info" -> Info
        | "warning" -> Warning
        | _ -> assert false

      and t_to_js : t -> Ojs.t =
        fun (x900 : t) ->
        match x900 with
        | Error -> Ojs.string_to_js "error"
        | Hint -> Ojs.string_to_js "hint"
        | Info -> Ojs.string_to_js "info"
        | Warning -> Ojs.string_to_js "warning"
      ;;
    end

    let create
      :  from:int -> to_:int -> severity:Severity.t -> ?mark_class:string
      -> ?source:string -> message:string -> unit -> t
      =
      fun ~from:(x903 : int)
        ~to_:(x904 : int)
        ~severity:(x905 : Severity.t)
        ?mark_class:(x906 : string option)
        ?source:(x907 : string option)
        ~message:(x908 : string)
        () ->
      let x909 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x909 "from" (Ojs.int_to_js x903);
      Ojs.set_prop_ascii x909 "to" (Ojs.int_to_js x904);
      Ojs.set_prop_ascii x909 "severity" (Severity.t_to_js x905);
      (match x906 with
       | Some x911 -> Ojs.set_prop_ascii x909 "markClass" (Ojs.string_to_js x911)
       | None -> ());
      (match x907 with
       | Some x910 -> Ojs.set_prop_ascii x909 "source" (Ojs.string_to_js x910)
       | None -> ());
      Ojs.set_prop_ascii x909 "message" (Ojs.string_to_js x908);
      t_of_js x909
    ;;
  end

  let set_diagnostics
    :  state:State.Editor_state.t -> diagnostics:Diagnostic.t list
    -> State.Transaction_spec.t
    =
    fun ~state:(x912 : State.Editor_state.t) ~diagnostics:(x913 : Diagnostic.t list) ->
    State.Transaction_spec.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "setDiagnostics"
         [| State.Editor_state.t_to_js x912; Ojs.list_to_js Diagnostic.t_to_js x913 |])
  ;;

  let diagnostic_count : State.Editor_state.t -> int =
    fun (x915 : State.Editor_state.t) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "diagnosticCount"
         [| State.Editor_state.t_to_js x915 |])
  ;;

  let lint_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "lintGutter"
         [||])
  ;;
end

module Commands = struct
  let standard_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "standardKeymap")
  ;;

  let default_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "defaultKeymap")
  ;;

  let emacs_style_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "emacsStyleKeymap")
  ;;

  let cursor_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharLeft")
  ;;

  let select_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharLeft")
  ;;

  let cursor_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupLeft")
  ;;

  let select_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupLeft")
  ;;

  let cursor_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharRight")
  ;;

  let select_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharRight")
  ;;

  let cursor_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupRight")
  ;;

  let select_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupRight")
  ;;

  let cursor_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineUp")
  ;;

  let select_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineUp")
  ;;

  let cursor_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineDown")
  ;;

  let select_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineDown")
  ;;

  let cursor_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageUp")
  ;;

  let select_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageUp")
  ;;

  let cursor_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageDown")
  ;;

  let select_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageDown")
  ;;

  let cursor_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryBackward")
  ;;

  let select_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryBackward")
  ;;

  let cursor_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocStart")
  ;;

  let select_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocStart")
  ;;

  let cursor_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryForward")
  ;;

  let select_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryForward")
  ;;

  let cursor_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocEnd")
  ;;

  let select_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocEnd")
  ;;

  let insert_newline_and_indent : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertNewlineAndIndent")
  ;;

  let select_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectAll")
  ;;

  let delete_char_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharBackward")
  ;;

  let delete_char_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharForward")
  ;;

  let delete_group_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupBackward")
  ;;

  let delete_group_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupForward")
  ;;

  let cursor_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxLeft")
  ;;

  let select_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxLeft")
  ;;

  let cursor_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxRight")
  ;;

  let select_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxRight")
  ;;

  let move_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineUp")
  ;;

  let copy_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineUp")
  ;;

  let move_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineDown")
  ;;

  let copy_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineDown")
  ;;

  let simplify_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "simplifySelection")
  ;;

  let select_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLine")
  ;;

  let select_parent_syntax : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectParentSyntax")
  ;;

  let indent_less : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentLess")
  ;;

  let indent_more : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentMore")
  ;;

  let indent_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentSelection")
  ;;

  let delete_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteLine")
  ;;

  let cursor_matching_bracket : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorMatchingBracket")
  ;;

  let toggle_comment : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "toggleComment")
  ;;
end

module Gutter = struct
  module Block_info = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x920 : Ojs.t) -> x920
    and t_to_js : t -> Ojs.t = fun (x919 : Ojs.t) -> x919

    let from : t -> int =
      fun (x921 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x921) "from")
    ;;

    let length : t -> int =
      fun (x922 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x922) "length")
    ;;

    let top : t -> int =
      fun (x923 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x923) "top")
    ;;

    let height : t -> int =
      fun (x924 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x924) "height")
    ;;

    let to_ : t -> int =
      fun (x925 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x925) "to")
    ;;

    let bottom : t -> int =
      fun (x926 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x926) "bottom")
    ;;
  end

  module Line_numbers_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x928 : Ojs.t) -> x928
    and t_to_js : t -> Ojs.t = fun (x927 : Ojs.t) -> x927

    module Dom_event_handlers = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x930 : Ojs.t) -> x930
      and t_to_js : t -> Ojs.t = fun (x929 : Ojs.t) -> x929

      let create : ?mousedown:(View.Editor_view.t -> Block_info.t -> unit) -> unit -> t =
        fun ?mousedown:(x931 : (View.Editor_view.t -> Block_info.t -> unit) option) () ->
        let x932 = Ojs.empty_obj () in
        (match x931 with
         | Some x933 ->
           Ojs.set_prop_ascii
             x932
             "mousedown"
             (Ojs.fun_to_js 2 (fun (x934 : Ojs.t) (x935 : Ojs.t) ->
                x933 (View.Editor_view.t_of_js x934) (Block_info.t_of_js x935)))
         | None -> ());
        t_of_js x932
      ;;
    end

    let create
      :  ?format_number:(int -> State.Editor_state.t -> string)
      -> ?dom_event_handlers:Dom_event_handlers.t -> unit -> t
      =
      fun ?format_number:(x936 : (int -> State.Editor_state.t -> string) option)
        ?dom_event_handlers:(x937 : Dom_event_handlers.t option)
        () ->
      let x938 = Ojs.empty_obj () in
      (match x936 with
       | Some x940 ->
         Ojs.set_prop_ascii
           x938
           "formatNumber"
           (Ojs.fun_to_js 2 (fun (x941 : Ojs.t) (x942 : Ojs.t) ->
              Ojs.string_to_js
                (x940 (Ojs.int_of_js x941) (State.Editor_state.t_of_js x942))))
       | None -> ());
      (match x937 with
       | Some x939 ->
         Ojs.set_prop_ascii x938 "domEventHandlers" (Dom_event_handlers.t_to_js x939)
       | None -> ());
      t_of_js x938
    ;;
  end

  let line_numbers : Line_numbers_config.t -> State.Extension.t =
    fun (x943 : Line_numbers_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "lineNumbers"
         [| Line_numbers_config.t_to_js x943 |])
  ;;

  let highlight_active_line_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLineGutter"
         [||])
  ;;
end

module History = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x945 : Ojs.t) -> x945
    and t_to_js : t -> Ojs.t = fun (x944 : Ojs.t) -> x944

    let create : ?min_depth:int -> ?new_group_delay:int -> unit -> t =
      fun ?min_depth:(x946 : int option) ?new_group_delay:(x947 : int option) () ->
      let x948 = Ojs.empty_obj () in
      (match x946 with
       | Some x950 -> Ojs.set_prop_ascii x948 "minDepth" (Ojs.int_to_js x950)
       | None -> ());
      (match x947 with
       | Some x949 -> Ojs.set_prop_ascii x948 "newGroupDelay" (Ojs.int_to_js x949)
       | None -> ());
      t_of_js x948
    ;;
  end

  let history : Config.t -> State.Extension.t =
    fun (x951 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "history"
         [| Config.t_to_js x951 |])
  ;;

  let undo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undo")
  ;;

  let redo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redo")
  ;;

  let undo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undoSelection")
  ;;

  let redo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redoSelection")
  ;;
end

module Search = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x953 : Ojs.t) -> x953
    and t_to_js : t -> Ojs.t = fun (x952 : Ojs.t) -> x952

    let create : ?top:bool -> ?match_case:bool -> unit -> t =
      fun ?top:(x954 : bool option) ?match_case:(x955 : bool option) () ->
      let x956 = Ojs.empty_obj () in
      (match x954 with
       | Some x958 -> Ojs.set_prop_ascii x956 "top" (Ojs.bool_to_js x958)
       | None -> ());
      (match x955 with
       | Some x957 -> Ojs.set_prop_ascii x956 "matchCase" (Ojs.bool_to_js x957)
       | None -> ());
      t_of_js x956
    ;;
  end

  let search : Config.t -> State.Extension.t =
    fun (x959 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "search"
         [| Config.t_to_js x959 |])
  ;;

  let find_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findNext")
  ;;

  let find_previous : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findPrevious")
  ;;

  let select_matches : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "selectMatches")
  ;;

  let replace_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceNext")
  ;;

  let replace_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceAll")
  ;;

  let open_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "openSearchPanel")
  ;;

  let close_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "closeSearchPanel")
  ;;

  let goto_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "gotoLine")
  ;;
end

module Basic_setup = struct
  let basic_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "basicSetup")
  ;;

  let minimal_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "minimalSetup")
  ;;
end

module Language = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x961 : Ojs.t) -> x961
  and t_to_js : t -> Ojs.t = fun (x960 : Ojs.t) -> x960

  let extension : t -> State.Extension.t =
    fun (x962 : t) ->
    State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js x962) "extension")
  ;;
end

module Stream_parser = struct
  module String_stream = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x964 : Ojs.t) -> x964
    and t_to_js : t -> Ojs.t = fun (x963 : Ojs.t) -> x963

    let new_string_stream : string:string -> tab_size:int -> indent_unit:int -> t =
      fun ~string:(x965 : string) ~tab_size:(x966 : int) ~indent_unit:(x967 : int) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StringStream")
           [| Ojs.string_to_js x965; Ojs.int_to_js x966; Ojs.int_to_js x967 |])
    ;;

    let pos : t -> int =
      fun (x968 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x968) "pos")
    ;;

    let set_pos : t -> int -> unit =
      fun (x969 : t) (x970 : int) ->
      Ojs.set_prop_ascii (t_to_js x969) "pos" (Ojs.int_to_js x970)
    ;;

    let start : t -> int =
      fun (x971 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x971) "start")
    ;;

    let string : t -> string =
      fun (x972 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x972) "string")
    ;;

    let eol : t -> bool =
      fun (x973 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x973) "eol" [||])
    ;;

    let sol : t -> bool =
      fun (x974 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x974) "sol" [||])
    ;;

    let peek : t -> string option =
      fun (x975 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x975) "peek" [||])
    ;;

    let next : t -> string option =
      fun (x977 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x977) "next" [||])
    ;;

    let current : t -> string =
      fun (x979 : t) -> Ojs.string_of_js (Ojs.call (t_to_js x979) "current" [||])
    ;;

    let skip_to_end : t -> unit =
      fun (x980 : t) -> ignore (Ojs.call (t_to_js x980) "skipToEnd" [||])
    ;;

    let eat_space : t -> bool =
      fun (x981 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x981) "eatSpace" [||])
    ;;

    let eat : t -> match_:string -> string option =
      fun (x983 : t) ~match_:(x982 : string) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x983) "eat" [| Ojs.string_to_js x982 |])
    ;;

    let eat_regex : t -> match_:RegExp.t -> string option =
      fun (x986 : t) ~match_:(x985 : RegExp.t) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x986) "eat" [| RegExp.t_to_js x985 |])
    ;;

    let eat_while : t -> match_:string -> bool =
      fun (x989 : t) ~match_:(x988 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x989) "eatWhile" [| Ojs.string_to_js x988 |])
    ;;

    let eat_while_regex : t -> match_:RegExp.t -> bool =
      fun (x991 : t) ~match_:(x990 : RegExp.t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x991) "eatWhile" [| RegExp.t_to_js x990 |])
    ;;

    let match_
      : t -> pattern:string -> ?consume:bool -> ?case_insensitive:bool -> unit -> bool
      =
      fun (x998 : t)
        ~pattern:(x992 : string)
        ?consume:(x993 : bool option)
        ?case_insensitive:(x994 : bool option)
        () ->
      Ojs.bool_of_js
        (let x999 = t_to_js x998 in
         Ojs.call
           (Ojs.get_prop_ascii x999 "match")
           "apply"
           [| x999
            ; (let x995 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x995 "push" [| Ojs.string_to_js x992 |]);
               (match x993 with
                | Some x997 -> ignore (Ojs.call x995 "push" [| Ojs.bool_to_js x997 |])
                | None -> ());
               (match x994 with
                | Some x996 -> ignore (Ojs.call x995 "push" [| Ojs.bool_to_js x996 |])
                | None -> ());
               x995)
           |])
    ;;

    let match_regex
      :  t -> pattern:RegExp.t -> ?consume:bool -> ?case_insensitive:bool -> unit
      -> string list option
      =
      fun (x1006 : t)
        ~pattern:(x1000 : RegExp.t)
        ?consume:(x1001 : bool option)
        ?case_insensitive:(x1002 : bool option)
        () ->
      Ojs.option_of_js
        (fun (x1008 : Ojs.t) -> Ojs.list_of_js Ojs.string_of_js x1008)
        (let x1007 = t_to_js x1006 in
         Ojs.call
           (Ojs.get_prop_ascii x1007 "match")
           "apply"
           [| x1007
            ; (let x1003 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x1003 "push" [| RegExp.t_to_js x1000 |]);
               (match x1001 with
                | Some x1005 -> ignore (Ojs.call x1003 "push" [| Ojs.bool_to_js x1005 |])
                | None -> ());
               (match x1002 with
                | Some x1004 -> ignore (Ojs.call x1003 "push" [| Ojs.bool_to_js x1004 |])
                | None -> ());
               x1003)
           |])
    ;;
  end

  module Stream_parser = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1011 : Ojs.t) -> x1011
    and t_to_js : t -> Ojs.t = fun (x1010 : Ojs.t) -> x1010

    let create
      :  ?language_data:Ojs.t -> start_state:(unit -> 'state)
      -> token:(String_stream.t -> 'state -> string option) -> unit -> t
      =
      fun ?language_data:(x1012 : Ojs.t option)
        ~start_state:(x1013 : unit -> 'state)
        ~token:(x1014 : String_stream.t -> 'state -> string option)
        () ->
      let x1015 = Ojs.empty_obj () in
      (match x1012 with
       | Some x1019 -> Ojs.set_prop_ascii x1015 "languageData" x1019
       | None -> ());
      Ojs.set_prop_ascii
        x1015
        "startState"
        (Ojs.fun_to_js 1 (fun _ -> Obj.magic (x1013 ())));
      Ojs.set_prop_ascii
        x1015
        "token"
        (Ojs.fun_to_js 2 (fun (x1016 : Ojs.t) (x1017 : Ojs.t) ->
           Ojs.option_to_js
             Ojs.string_to_js
             (x1014 (String_stream.t_of_js x1016) (Obj.magic x1017))));
      t_of_js x1015
    ;;
  end

  module Stream_language = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1021 : Ojs.t) -> x1021
    and t_to_js : t -> Ojs.t = fun (x1020 : Ojs.t) -> x1020

    let define : Stream_parser.t -> t =
      fun (x1022 : Stream_parser.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StreamLanguage")
           "define"
           [| Stream_parser.t_to_js x1022 |])
    ;;

    let to_language : t -> Language.t =
      fun (x1023 : t) -> Language.t_of_js (t_to_js x1023)
    ;;
  end
end

module Mllike = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1025 : Ojs.t) -> x1025
  and t_to_js : t -> Ojs.t = fun (x1024 : Ojs.t) -> x1024

  let ocaml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "oCaml")
  ;;

  let fsharp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "fSharp")
  ;;

  let sml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "sml")
  ;;
end

module Diff = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1027 : Ojs.t) -> x1027
  and t_to_js : t -> Ojs.t = fun (x1026 : Ojs.t) -> x1026

  let diff : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_diff")
         "diff")
  ;;
end

module Commonlisp = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1029 : Ojs.t) -> x1029
  and t_to_js : t -> Ojs.t = fun (x1028 : Ojs.t) -> x1028

  let common_lisp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_commonlisp")
         "commonLisp")
  ;;
end

module Scheme = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1031 : Ojs.t) -> x1031
  and t_to_js : t -> Ojs.t = fun (x1030 : Ojs.t) -> x1030

  let scheme : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_scheme")
         "scheme")
  ;;
end

module Lezer_highlight = struct
  module Highlighter = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1033 : Ojs.t) -> x1033
    and t_to_js : t -> Ojs.t = fun (x1032 : Ojs.t) -> x1032
  end

  module Tag = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1035 : Ojs.t) -> x1035
    and t_to_js : t -> Ojs.t = fun (x1034 : Ojs.t) -> x1034
  end

  module Tags = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1037 : Ojs.t) -> x1037
    and t_to_js : t -> Ojs.t = fun (x1036 : Ojs.t) -> x1036

    let arithmetic_operator : t -> Tag.t =
      fun (x1038 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1038) "arithmeticOperator")
    ;;

    let bool : t -> Tag.t =
      fun (x1039 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1039) "bool")
    ;;

    let bracket : t -> Tag.t =
      fun (x1040 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1040) "bracket")
    ;;

    let comment : t -> Tag.t =
      fun (x1041 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1041) "comment")
    ;;

    let compare_operator : t -> Tag.t =
      fun (x1042 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1042) "compareOperator")
    ;;

    let content : t -> Tag.t =
      fun (x1043 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1043) "content")
    ;;

    let control_keyword : t -> Tag.t =
      fun (x1044 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1044) "controlKeyword")
    ;;

    let definition_keyword : t -> Tag.t =
      fun (x1045 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1045) "definitionKeyword")
    ;;

    let doc_comment : t -> Tag.t =
      fun (x1046 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1046) "docComment")
    ;;

    let invalid : t -> Tag.t =
      fun (x1047 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1047) "invalid")
    ;;

    let keyword : t -> Tag.t =
      fun (x1048 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1048) "keyword")
    ;;

    let literal : t -> Tag.t =
      fun (x1049 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1049) "literal")
    ;;

    let logic_operator : t -> Tag.t =
      fun (x1050 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1050) "logicOperator")
    ;;

    let macro_name : t -> Tag.t =
      fun (x1051 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1051) "macroName")
    ;;

    let name : t -> Tag.t =
      fun (x1052 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1052) "name")
    ;;

    let number : t -> Tag.t =
      fun (x1053 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1053) "number")
    ;;

    let operator : t -> Tag.t =
      fun (x1054 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1054) "operator")
    ;;

    let paren : t -> Tag.t =
      fun (x1055 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1055) "paren")
    ;;

    let punctuation : t -> Tag.t =
      fun (x1056 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1056) "punctuation")
    ;;

    let string : t -> Tag.t =
      fun (x1057 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1057) "string")
    ;;

    let type_name : t -> Tag.t =
      fun (x1058 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1058) "typeName")
    ;;
  end

  let tags : Tags.t =
    Tags.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "tags")
  ;;

  let class_highlighter : Highlighter.t =
    Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "classHighlighter")
  ;;
end

module Highlight = struct
  module Syntax_highlighting_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1060 : Ojs.t) -> x1060
    and t_to_js : t -> Ojs.t = fun (x1059 : Ojs.t) -> x1059

    let create : ?fallback:bool -> unit -> t =
      fun ?fallback:(x1061 : bool option) () ->
      let x1062 = Ojs.empty_obj () in
      (match x1061 with
       | Some x1063 -> Ojs.set_prop_ascii x1062 "fallback" (Ojs.bool_to_js x1063)
       | None -> ());
      t_of_js x1062
    ;;
  end

  module Highlight_style = struct
    let define : specs:Ojs.t list -> Lezer_highlight.Highlighter.t =
      fun ~specs:(x1064 : Ojs.t list) ->
      Lezer_highlight.Highlighter.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "HighlightStyle")
           "define"
           [| Ojs.list_to_js (fun (x1065 : Ojs.t) -> x1065) x1064 |])
    ;;
  end

  let syntax_highlighting
    :  Lezer_highlight.Highlighter.t -> ?options:Syntax_highlighting_options.t -> unit
    -> State.Extension.t
    =
    fun (x1066 : Lezer_highlight.Highlighter.t)
      ?options:(x1067 : Syntax_highlighting_options.t option)
      () ->
    State.Extension.t_of_js
      (let x1070 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1070 "syntaxHighlighting")
         "apply"
         [| x1070
          ; (let x1068 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore
               (Ojs.call x1068 "push" [| Lezer_highlight.Highlighter.t_to_js x1066 |]);
             (match x1067 with
              | Some x1069 ->
                ignore
                  (Ojs.call x1068 "push" [| Syntax_highlighting_options.t_to_js x1069 |])
              | None -> ());
             x1068)
         |])
  ;;

  let default_highlight_style : Lezer_highlight.Highlighter.t =
    Lezer_highlight.Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "defaultHighlightStyle")
  ;;
end

module Folding = struct
  module Fold = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1072 : Ojs.t) -> x1072
    and t_to_js : t -> Ojs.t = fun (x1071 : Ojs.t) -> x1071

    let create : from:int -> to_:int -> t =
      fun ~from:(x1073 : int) ~to_:(x1074 : int) ->
      let x1075 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1075 "from" (Ojs.int_to_js x1073);
      Ojs.set_prop_ascii x1075 "to" (Ojs.int_to_js x1074);
      t_of_js x1075
    ;;
  end

  module Fold_service_callback = struct
    type t = State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option

    let rec t_of_js : Ojs.t -> t =
      fun (x1081 : Ojs.t)
        (x1082 : State.Editor_state.t)
        ~line_start:(x1083 : int)
        ~line_end:(x1084 : int) ->
      Ojs.option_of_js
        Fold.t_of_js
        (Ojs.apply
           x1081
           [| State.Editor_state.t_to_js x1082
            ; Ojs.int_to_js x1083
            ; Ojs.int_to_js x1084
           |])

    and t_to_js : t -> Ojs.t =
      fun (x1076 :
            State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option) ->
      Ojs.fun_to_js 3 (fun (x1077 : Ojs.t) (x1078 : Ojs.t) (x1079 : Ojs.t) ->
        Ojs.option_to_js
          Fold.t_to_js
          (x1076
             (State.Editor_state.t_of_js x1077)
             ~line_start:(Ojs.int_of_js x1078)
             ~line_end:(Ojs.int_of_js x1079)))
    ;;
  end

  let fold_service : (Fold_service_callback.t, Fold_service_callback.t) State.Facet.t =
    State.Facet.t_of_js
      Fold_service_callback.t_of_js
      Fold_service_callback.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldService")
  ;;

  let fold_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldGutter"
         [||])
  ;;
end

module Matchbrackets = struct
  let bracket_matching : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "bracketMatching"
         [||])
  ;;
end

module Lang_markdown = struct
  let markdown : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_markdown")
         "markdown"
         [||])
  ;;
end

module Lang_python = struct
  let python : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_python")
         "python"
         [||])
  ;;
end

module Lang_sql = struct
  module Sql_dialect_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1089 : Ojs.t) -> x1089
    and t_to_js : t -> Ojs.t = fun (x1088 : Ojs.t) -> x1088

    let create
      :  ?keywords:string -> ?builtin:string -> ?types:string -> ?backslash_escapes:string
      -> ?hash_comments:bool -> ?slash_comments:bool -> ?space_after_dashes:bool
      -> ?double_quoted_strings:bool -> ?char_set_casts:bool -> ?operator_chars:string
      -> ?special_var:string -> ?identifier_quotes:string -> unit -> t
      =
      fun ?keywords:(x1090 : string option)
        ?builtin:(x1091 : string option)
        ?types:(x1092 : string option)
        ?backslash_escapes:(x1093 : string option)
        ?hash_comments:(x1094 : bool option)
        ?slash_comments:(x1095 : bool option)
        ?space_after_dashes:(x1096 : bool option)
        ?double_quoted_strings:(x1097 : bool option)
        ?char_set_casts:(x1098 : bool option)
        ?operator_chars:(x1099 : string option)
        ?special_var:(x1100 : string option)
        ?identifier_quotes:(x1101 : string option)
        () ->
      let x1102 = Ojs.empty_obj () in
      (match x1090 with
       | Some x1114 -> Ojs.set_prop_ascii x1102 "keywords" (Ojs.string_to_js x1114)
       | None -> ());
      (match x1091 with
       | Some x1113 -> Ojs.set_prop_ascii x1102 "builtin" (Ojs.string_to_js x1113)
       | None -> ());
      (match x1092 with
       | Some x1112 -> Ojs.set_prop_ascii x1102 "types" (Ojs.string_to_js x1112)
       | None -> ());
      (match x1093 with
       | Some x1111 ->
         Ojs.set_prop_ascii x1102 "backslashEscapes" (Ojs.string_to_js x1111)
       | None -> ());
      (match x1094 with
       | Some x1110 -> Ojs.set_prop_ascii x1102 "hashComments" (Ojs.bool_to_js x1110)
       | None -> ());
      (match x1095 with
       | Some x1109 -> Ojs.set_prop_ascii x1102 "slashComments" (Ojs.bool_to_js x1109)
       | None -> ());
      (match x1096 with
       | Some x1108 -> Ojs.set_prop_ascii x1102 "spaceAfterDashes" (Ojs.bool_to_js x1108)
       | None -> ());
      (match x1097 with
       | Some x1107 ->
         Ojs.set_prop_ascii x1102 "doubleQuotedStrings" (Ojs.bool_to_js x1107)
       | None -> ());
      (match x1098 with
       | Some x1106 -> Ojs.set_prop_ascii x1102 "charSetCasts" (Ojs.bool_to_js x1106)
       | None -> ());
      (match x1099 with
       | Some x1105 -> Ojs.set_prop_ascii x1102 "operatorChars" (Ojs.string_to_js x1105)
       | None -> ());
      (match x1100 with
       | Some x1104 -> Ojs.set_prop_ascii x1102 "specialVar" (Ojs.string_to_js x1104)
       | None -> ());
      (match x1101 with
       | Some x1103 ->
         Ojs.set_prop_ascii x1102 "identifierQuotes" (Ojs.string_to_js x1103)
       | None -> ());
      t_of_js x1102
    ;;
  end

  module Sql_dialect = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1116 : Ojs.t) -> x1116
    and t_to_js : t -> Ojs.t = fun (x1115 : Ojs.t) -> x1115

    let define : spec:Sql_dialect_spec.t -> t =
      fun ~spec:(x1117 : Sql_dialect_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
              "SQLDialect")
           "define"
           [| Sql_dialect_spec.t_to_js x1117 |])
    ;;
  end

  module Sql_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1119 : Ojs.t) -> x1119
    and t_to_js : t -> Ojs.t = fun (x1118 : Ojs.t) -> x1118

    let create
      :  ?dialect:Sql_dialect.t -> ?upper_case_keywords:bool
      -> ?tables:Autocomplete.Completion.t list -> ?default_table:int -> ?schema:Ojs.t
      -> unit -> t
      =
      fun ?dialect:(x1120 : Sql_dialect.t option)
        ?upper_case_keywords:(x1121 : bool option)
        ?tables:(x1122 : Autocomplete.Completion.t list option)
        ?default_table:(x1123 : int option)
        ?schema:(x1124 : Ojs.t option)
        () ->
      let x1125 = Ojs.empty_obj () in
      (match x1120 with
       | Some x1131 -> Ojs.set_prop_ascii x1125 "dialect" (Sql_dialect.t_to_js x1131)
       | None -> ());
      (match x1121 with
       | Some x1130 -> Ojs.set_prop_ascii x1125 "upperCaseKeywords" (Ojs.bool_to_js x1130)
       | None -> ());
      (match x1122 with
       | Some x1128 ->
         Ojs.set_prop_ascii
           x1125
           "tables"
           (Ojs.list_to_js Autocomplete.Completion.t_to_js x1128)
       | None -> ());
      (match x1123 with
       | Some x1127 -> Ojs.set_prop_ascii x1125 "defaultTable" (Ojs.int_to_js x1127)
       | None -> ());
      (match x1124 with
       | Some x1126 -> Ojs.set_prop_ascii x1125 "schema" x1126
       | None -> ());
      t_of_js x1125
    ;;
  end

  let postgresql : Sql_dialect.t =
    Sql_dialect.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
         "PostgreSQL")
  ;;

  let sql : ?config:Sql_config.t -> unit -> Language.t =
    fun ?config:(x1132 : Sql_config.t option) () ->
    Language.t_of_js
      (let x1135 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1135 "sql")
         "apply"
         [| x1135
          ; (let x1133 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x1132 with
              | Some x1134 ->
                ignore (Ojs.call x1133 "push" [| Sql_config.t_to_js x1134 |])
              | None -> ());
             x1133)
         |])
  ;;
end

module Lang_html = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1137 : Ojs.t) -> x1137
  and t_to_js : t -> Ojs.t = fun (x1136 : Ojs.t) -> x1136

  let html : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_html")
         "html"
         [||])
  ;;
end

module Lang_css = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1139 : Ojs.t) -> x1139
  and t_to_js : t -> Ojs.t = fun (x1138 : Ojs.t) -> x1138

  let css : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_css")
         "css"
         [||])
  ;;
end

module Lang_javascript = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1141 : Ojs.t) -> x1141
  and t_to_js : t -> Ojs.t = fun (x1140 : Ojs.t) -> x1140

  let javascript : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lang_javascript")
         "javascript"
         [||])
  ;;
end

module Lang_php = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1143 : Ojs.t) -> x1143
  and t_to_js : t -> Ojs.t = fun (x1142 : Ojs.t) -> x1142

  let php : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_php")
         "php"
         [||])
  ;;
end

module Lang_rust = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1145 : Ojs.t) -> x1145
  and t_to_js : t -> Ojs.t = fun (x1144 : Ojs.t) -> x1144

  let rust : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_rust")
         "rust"
         [||])
  ;;
end

module Lang_xml = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1147 : Ojs.t) -> x1147
  and t_to_js : t -> Ojs.t = fun (x1146 : Ojs.t) -> x1146

  let xml : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_xml")
         "xml"
         [||])
  ;;
end

module Merge = struct
  module Unified_merge_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1149 : Ojs.t) -> x1149
    and t_to_js : t -> Ojs.t = fun (x1148 : Ojs.t) -> x1148

    let create_from_string
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> string -> t
      =
      fun ?highlight_changes:(x1150 : bool option)
        ?gutter:(x1151 : bool option)
        ?syntax_highlight_deletions:(x1152 : bool option)
        ?merge_controls:(x1153 : bool option)
        (x1154 : string) ->
      let x1155 = Ojs.empty_obj () in
      (match x1150 with
       | Some x1159 -> Ojs.set_prop_ascii x1155 "highlightChanges" (Ojs.bool_to_js x1159)
       | None -> ());
      (match x1151 with
       | Some x1158 -> Ojs.set_prop_ascii x1155 "gutter" (Ojs.bool_to_js x1158)
       | None -> ());
      (match x1152 with
       | Some x1157 ->
         Ojs.set_prop_ascii x1155 "syntaxHighlightDeletions" (Ojs.bool_to_js x1157)
       | None -> ());
      (match x1153 with
       | Some x1156 -> Ojs.set_prop_ascii x1155 "mergeControls" (Ojs.bool_to_js x1156)
       | None -> ());
      Ojs.set_prop_ascii x1155 "original" (Ojs.string_to_js x1154);
      t_of_js x1155
    ;;

    let create_from_text
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> Text.Text.t -> t
      =
      fun ?highlight_changes:(x1160 : bool option)
        ?gutter:(x1161 : bool option)
        ?syntax_highlight_deletions:(x1162 : bool option)
        ?merge_controls:(x1163 : bool option)
        (x1164 : Text.Text.t) ->
      let x1165 = Ojs.empty_obj () in
      (match x1160 with
       | Some x1169 -> Ojs.set_prop_ascii x1165 "highlightChanges" (Ojs.bool_to_js x1169)
       | None -> ());
      (match x1161 with
       | Some x1168 -> Ojs.set_prop_ascii x1165 "gutter" (Ojs.bool_to_js x1168)
       | None -> ());
      (match x1162 with
       | Some x1167 ->
         Ojs.set_prop_ascii x1165 "syntaxHighlightDeletions" (Ojs.bool_to_js x1167)
       | None -> ());
      (match x1163 with
       | Some x1166 -> Ojs.set_prop_ascii x1165 "mergeControls" (Ojs.bool_to_js x1166)
       | None -> ());
      Ojs.set_prop_ascii x1165 "original" (Text.Text.t_to_js x1164);
      t_of_js x1165
    ;;
  end

  let unified_merge_view : Unified_merge_config.t -> State.Extension.t =
    fun (x1170 : Unified_merge_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Merge")
         "unifiedMergeView"
         [| Unified_merge_config.t_to_js x1170 |])
  ;;
end
